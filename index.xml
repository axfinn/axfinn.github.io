<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>jaxiu He</title>
    <link>https://axfinn.github.io/</link>
    <description>Recent content on jaxiu He</description>
    <generator>Hugo</generator>
    <language>zn-Hans</language>
    <lastBuildDate>Sun, 03 Aug 2025 20:00:00 +0800</lastBuildDate>
    <atom:link href="https://axfinn.github.io/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>todoIng 架构设计与未来展望</title>
      <link>https://axfinn.github.io/blog/2025-08/todoing-architecture-and-future/</link>
      <pubDate>Sun, 03 Aug 2025 20:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-08/todoing-architecture-and-future/</guid>
      <description>&lt;h1 id=&#34;todoing-架构设计与未来展望&#34;&gt;todoIng 架构设计与未来展望&lt;/h1&gt;&#xA;&lt;p&gt;在前面的系列文章中，我们详细介绍了 todoIng 项目的各个功能模块和实现细节。今天，我们将从更高的层面来审视整个系统的架构设计，并探讨其未来的发展方向。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体架构回顾&#34;&gt;整体架构回顾&lt;/h2&gt;&#xA;&lt;p&gt;todoIng 采用现代化的前后端分离架构，这种设计模式为系统带来了诸多优势：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;技术栈独立&lt;/strong&gt;：前后端可以使用最适合各自领域的技术栈&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;开发效率&lt;/strong&gt;：前后端团队可以并行开发，互不干扰&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：前后端可以独立扩展和部署&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;维护性&lt;/strong&gt;：代码结构清晰，易于维护和重构&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;让我们回顾一下 todoIng 的整体架构：&lt;/p&gt;</description>
    </item>
    <item>
      <title>todoIng 部署架构与运维策略</title>
      <link>https://axfinn.github.io/blog/2025-08/todoing-deployment-and-best-practices/</link>
      <pubDate>Sun, 03 Aug 2025 16:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-08/todoing-deployment-and-best-practices/</guid>
      <description>&lt;h1 id=&#34;todoing-部署架构与运维策略&#34;&gt;todoIng 部署架构与运维策略&lt;/h1&gt;&#xA;&lt;p&gt;在前面的系列文章中，我们详细介绍了 todoIng 的各项功能和实现原理。今天，我们将探讨如何部署 todoIng 应用，并分享一些在实际部署过程中的最佳实践。&lt;/p&gt;&#xA;&lt;h2 id=&#34;部署方案概览&#34;&gt;部署方案概览&lt;/h2&gt;&#xA;&lt;p&gt;todoIng 支持多种部署方式，以适应不同的使用场景和需求。我们的部署架构设计遵循了现代化应用部署的最佳实践，确保系统具有高可用性、可扩展性和安全性。&lt;/p&gt;&#xA;&lt;h3 id=&#34;部署架构设计&#34;&gt;部署架构设计&lt;/h3&gt;&#xA;&lt;p&gt;todoIng 的部署架构采用分层设计：&lt;/p&gt;&#xA;&lt;div class=&#34;mermaid&#34;&gt;&#xA;&#xA;graph TD&#xA;    A[用户访问] --&gt; B{负载均衡器}&#xA;    B --&gt; C[前端服务集群]&#xA;    B --&gt; D[后端服务集群]&#xA;    C --&gt; E[(MongoDB集群)]&#xA;    D --&gt; E&#xA;    D --&gt; F[Redis缓存]&#xA;    D --&gt; G[AI服务接口]&#xA;    &#xA;    subgraph 应用层&#xA;        C&#xA;        D&#xA;    end&#xA;    &#xA;    subgraph 数据层&#xA;        E&#xA;        F&#xA;    end&#xA;    &#xA;    subgraph 外部服务&#xA;        G&#xA;    end&#xA;&#xA;&lt;/div&gt;&#xA;&lt;p&gt;这种架构的优势：&lt;/p&gt;</description>
    </item>
    <item>
      <title>todoIng AI 报告生成系统设计与智能应用</title>
      <link>https://axfinn.github.io/blog/2025-08/todoing-ai-report-generation/</link>
      <pubDate>Sun, 03 Aug 2025 10:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-08/todoing-ai-report-generation/</guid>
      <description>&lt;h1 id=&#34;todoing-ai-报告生成系统设计与智能应用&#34;&gt;todoIng AI 报告生成系统设计与智能应用&lt;/h1&gt;&#xA;&lt;p&gt;在之前的文章中，我们详细介绍了 todoIng 的核心功能，包括任务管理、历史追踪和团队协作。今天，我们将探讨 todoIng 的一大亮点功能——AI 报告生成。通过集成 OpenAI，todoIng 能够自动生成并润色日报、周报和月报，大大减轻了用户的工作负担。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要-ai-报告生成&#34;&gt;为什么需要 AI 报告生成？&lt;/h2&gt;&#xA;&lt;p&gt;在现代职场中，定期撰写工作报告是一项常见但耗时的任务。许多人在写报告时面临以下挑战：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;时间成本高&lt;/strong&gt;：整理任务完成情况、总结工作成果需要大量时间&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;表达困难&lt;/strong&gt;：难以用恰当的语言描述工作内容和成果&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;格式不统一&lt;/strong&gt;：缺乏标准化的报告模板&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;内容不全面&lt;/strong&gt;：容易遗漏重要信息&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;为了解决这些问题，todoIng 集成了 AI 报告生成功能，利用人工智能技术自动生成高质量的工作报告。&lt;/p&gt;</description>
    </item>
    <item>
      <title>todoIng 团队协作与权限管理架构设计</title>
      <link>https://axfinn.github.io/blog/2025-08/todoing-team-collaboration-and-permissions/</link>
      <pubDate>Sat, 02 Aug 2025 15:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-08/todoing-team-collaboration-and-permissions/</guid>
      <description>&lt;h1 id=&#34;todoing-团队协作与权限管理架构设计&#34;&gt;todoIng 团队协作与权限管理架构设计&lt;/h1&gt;&#xA;&lt;p&gt;在前面的文章中，我们已经介绍了 todoIng 的核心模块和 Git 风格的历史追踪系统。今天我们来探讨 todoIng 的团队协作功能和权限管理系统，这是实现高效团队任务管理的关键。&lt;/p&gt;&#xA;&lt;h2 id=&#34;团队协作的重要性&#34;&gt;团队协作的重要性&lt;/h2&gt;&#xA;&lt;p&gt;在现代工作中，很少有任务是完全独立完成的。大多数项目都需要团队成员之间的协作，这就要求任务管理系统具备强大的团队协作功能：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;任务分配&lt;/strong&gt;：能够将任务分配给特定的团队成员&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;进度共享&lt;/strong&gt;：团队成员可以实时查看任务进度&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;沟通协作&lt;/strong&gt;：在任务上下文中进行讨论和沟通&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;权限控制&lt;/strong&gt;：确保每个成员只能访问和操作自己有权限的内容&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;系统设计思路&#34;&gt;系统设计思路&lt;/h2&gt;&#xA;&lt;p&gt;todoIng 的团队协作系统采用了基于角色的访问控制（RBAC）模型，并结合了项目组的概念来组织团队成员和任务。&lt;/p&gt;</description>
    </item>
    <item>
      <title>todoIng Git 风格历史追踪系统设计与架构</title>
      <link>https://axfinn.github.io/blog/2025-08/todoing-git-style-history-tracking/</link>
      <pubDate>Sat, 02 Aug 2025 09:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-08/todoing-git-style-history-tracking/</guid>
      <description>&lt;h1 id=&#34;todoing-git-风格历史追踪系统设计与架构&#34;&gt;todoIng Git 风格历史追踪系统设计与架构&lt;/h1&gt;&#xA;&lt;p&gt;在前面的文章中，我们介绍了 todoIng 项目的核心模块设计。今天，我们将深入探讨 todoIng 最具特色的功能——Git 风格的任务历史追踪系统。这个功能使得 todoIng 与其他任务管理工具区别开来，为用户提供了前所未有的任务管理体验。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么需要任务历史追踪&#34;&gt;为什么需要任务历史追踪？&lt;/h2&gt;&#xA;&lt;p&gt;在传统的任务管理工具中，我们只能看到任务的当前状态，而无法了解任务是如何一步步演进的。这导致了以下几个问题：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;缺乏上下文&lt;/strong&gt;：无法了解任务状态变更的原因和背景&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;责任不明确&lt;/strong&gt;：不清楚是谁在什么时候做了什么变更&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;无法回溯&lt;/strong&gt;：当任务状态出现异常时，无法回溯到之前的正确状态&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;分析困难&lt;/strong&gt;：难以分析任务完成的效率和模式&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;为了解决这些问题，todoIng 引入了 Git 风格的任务历史追踪系统，为每个任务维护完整的变更历史。&lt;/p&gt;</description>
    </item>
    <item>
      <title>todoIng 核心模块设计与架构</title>
      <link>https://axfinn.github.io/blog/2025-08/todoing-core-modules-implementation/</link>
      <pubDate>Fri, 01 Aug 2025 14:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-08/todoing-core-modules-implementation/</guid>
      <description>&lt;h1 id=&#34;todoing-核心模块设计与架构&#34;&gt;todoIng 核心模块设计与架构&lt;/h1&gt;&#xA;&lt;p&gt;在上一篇文章中，我们介绍了 todoIng 项目的整体概况和主要特性。今天，我们将深入探讨 todoIng 的核心模块设计和系统架构。这些模块是整个系统的基础，为其他高级功能提供了支撑。&lt;/p&gt;&#xA;&lt;h2 id=&#34;项目架构概览&#34;&gt;项目架构概览&lt;/h2&gt;&#xA;&lt;p&gt;todoIng 采用现代化的前后端分离架构设计，这种架构模式带来了许多优势：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;技术栈独立&lt;/strong&gt;：前端和后端可以使用最适合各自领域的技术栈&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;开发效率&lt;/strong&gt;：前后端团队可以并行开发，互不干扰&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;可扩展性&lt;/strong&gt;：前后端可以独立扩展和部署&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;维护性&lt;/strong&gt;：代码结构清晰，易于维护和重构&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;下面是 todoIng 的整体架构图：&lt;/p&gt;</description>
    </item>
    <item>
      <title>todoIng 项目概览：像管理代码一样管理你的任务</title>
      <link>https://axfinn.github.io/blog/2025-08/todoing-project-overview/</link>
      <pubDate>Fri, 01 Aug 2025 10:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-08/todoing-project-overview/</guid>
      <description>&lt;h1 id=&#34;todoing-项目概览像管理代码一样管理你的任务&#34;&gt;todoIng 项目概览：像管理代码一样管理你的任务&lt;/h1&gt;&#xA;&lt;p&gt;在当今快节奏的工作环境中，任务管理工具已成为我们日常工作不可或缺的一部分。然而，大多数任务管理工具只能记录任务的当前状态，缺乏对任务完整生命周期的追踪。为了解决这个问题，我开发了 todoIng - 一个创新的任务管理系统，它不仅提供基本的任务管理功能，还为每个任务提供完整的生命周期追踪和变更历史记录，就像 Git 管理代码变更一样管理任务。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是-todoing&#34;&gt;什么是 todoIng？&lt;/h2&gt;&#xA;&lt;p&gt;todoIng 是一个现代化的任务管理系统，其核心理念是将软件开发中的版本控制概念应用到任务管理中。正如 Git 能够追踪代码的每一次变更一样，todoIng 能够追踪任务从创建到完成的每一个状态变化，为用户提供完整的任务历史记录。&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat 系列总结：构建下一代 AI 交互平台的完整解析</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-series-summary/</link>
      <pubDate>Thu, 31 Jul 2025 22:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-series-summary/</guid>
      <description>&lt;h1 id=&#34;deepchat-系列总结构建下一代-ai-交互平台的完整解析&#34;&gt;DeepChat 系列总结：构建下一代 AI 交互平台的完整解析&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在过去的一系列文章中，我们深入探讨了 &lt;a href=&#34;file:///Volumes/M20/code/docs/axfinn_blogs/content/blog/deepchat-mcp-support.md#L27-L27&#34;&gt;DeepChat&lt;/a&gt; 这一开源 AI 聊天平台的各个方面。从项目概览到具体的技术实现，从架构设计到企业级应用，我们全面剖析了这个功能强大的多模型 AI 对话平台。本文将对整个系列进行总结，并展望 AI 交互平台的未来发展趋势。&lt;/p&gt;&#xA;&lt;h2 id=&#34;系列文章回顾&#34;&gt;系列文章回顾&lt;/h2&gt;&#xA;&lt;p&gt;我们一共发布了 8 篇关于 DeepChat 的深度分析文章，涵盖了以下关键主题：&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-项目概览与核心特性&#34;&gt;1. 项目概览与核心特性&lt;/h3&gt;&#xA;&lt;p&gt;在&lt;a href=&#34;file:///Volumes/M20/code/docs/axfinn_blogs/content/blog/deepchat-project-overview.md&#34;&gt;第一篇文章&lt;/a&gt;中，我们介绍了 DeepChat 的基本概念和核心特性。DeepChat 作为一个多模型 AI 聊天平台，支持几乎所有主流的大语言模型，包括云端模型（如 OpenAI、Gemini、Anthropic）和本地模型（通过 Ollama）。其统一的接口设计让用户可以在一个应用中无缝切换不同的 AI 模型。&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat 性能优化与企业级应用</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-performance-enterprise/</link>
      <pubDate>Thu, 31 Jul 2025 21:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-performance-enterprise/</guid>
      <description>&lt;h1 id=&#34;deepchat-性能优化与企业级应用&#34;&gt;DeepChat 性能优化与企业级应用&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;随着 AI 技术的快速发展，越来越多的企业开始将 AI 工具集成到其工作流程中。DeepChat 作为一个功能强大的开源 AI 聊天平台，不仅适用于个人用户，也具备了企业级应用的潜力。本文将深入探讨 DeepChat 的性能优化策略和企业级应用实践。&lt;/p&gt;&#xA;&lt;h2 id=&#34;架构层面的性能优化&#34;&gt;架构层面的性能优化&lt;/h2&gt;&#xA;&lt;h3 id=&#34;内存管理优化&#34;&gt;内存管理优化&lt;/h3&gt;&#xA;&lt;p&gt;DeepChat 采用了多种内存管理策略来优化性能：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;class&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;MemoryOptimizer&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kr&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;memoryThreshold&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;number&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1024&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1024&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;*&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;1024&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 1GB&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kr&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;gcInterval&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;NodeJS.Timeout&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;|&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;kc&#34;&gt;null&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;kr&#34;&gt;constructor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;startMemoryMonitoring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 监控内存使用情况&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kr&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;startMemoryMonitoring&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gcInterval&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;setInterval&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(()&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;memoryUsage&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;memoryUsage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;// 检查内存使用是否超过阈值&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;memoryUsage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;heapUsed&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;memoryThreshold&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;performGarbageCollection&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;// 记录内存使用情况&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;this&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;logMemoryUsage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;memoryUsage&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;},&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;30000&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt; &lt;span class=&#34;c1&#34;&gt;// 每30秒检查一次&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 执行垃圾回收&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kr&#34;&gt;private&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;performGarbageCollection&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;()&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;void&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 卸载不活跃的会话&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;SessionManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;unloadInactiveSessions&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 清理缓存&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;nx&#34;&gt;CacheManager&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;getInstance&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;cleanup&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 如果支持，触发 Node.js 垃圾回收&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kr&#34;&gt;global&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;kr&#34;&gt;global&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;gc&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;();&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;c1&#34;&gt;// 优化大型数据处理&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;  &lt;span class=&#34;kr&#34;&gt;async&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;processLargeData&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[],&lt;/span&gt; &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;processor&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;item&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;T&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Promise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;any&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;,&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;batchSize&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;number&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;100&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;:&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Promise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&#34;nt&#34;&gt;any&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;[]&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;results&lt;/span&gt;: &lt;span class=&#34;kt&#34;&gt;any&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;[]&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;[];&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;c1&#34;&gt;// 分批处理数据以避免内存溢出&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;    &lt;span class=&#34;k&#34;&gt;for&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;kd&#34;&gt;let&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;mi&#34;&gt;0&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;&amp;lt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;length&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;batchSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;batch&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;data&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;slice&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;,&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;i&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;+&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;batchSize&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;kr&#34;&gt;const&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;batchResults&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Promise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;all&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;        &lt;span class=&#34;nx&#34;&gt;batch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;map&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;item&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;processor&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;item&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;))&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;nx&#34;&gt;results&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;push&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(...&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;batchResults&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;      &lt;span class=&#34;c1&#34;&gt;// 给事件循环一些时间&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;      &lt;span class=&#34;k&#34;&gt;await&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;new&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;Promise&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;resolve&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;setImmediate&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;resolve&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;k&#34;&gt;return&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;results&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;渲染性能优化&#34;&gt;渲染性能优化&lt;/h3&gt;&#xA;&lt;p&gt;针对 UI 渲染性能，DeepChat 采用了多种优化技术：&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat 安全与隐私保护机制</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-security-privacy/</link>
      <pubDate>Thu, 31 Jul 2025 21:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-security-privacy/</guid>
      <description>&lt;h1 id=&#34;deepchat-安全与隐私保护机制&#34;&gt;DeepChat 安全与隐私保护机制&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在当今数字化时代，用户对个人数据的安全和隐私保护越来越关注。作为一个 AI 聊天平台，DeepChat 处理着大量敏感的用户对话数据，因此必须建立完善的安全和隐私保护机制。本文将深入分析 DeepChat 在数据安全、隐私保护和访问控制等方面的实现。&lt;/p&gt;&#xA;&lt;h2 id=&#34;安全架构设计&#34;&gt;安全架构设计&lt;/h2&gt;&#xA;&lt;h3 id=&#34;整体安全架构&#34;&gt;整体安全架构&lt;/h3&gt;&#xA;&lt;p&gt;DeepChat 采用了分层的安全架构设计：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;┌─────────────────────────────────────────────────────────────────────┐&#xA;│                        DeepChat 安全架构                            │&#xA;├─────────────────────────────────────────────────────────────────────┤&#xA;│  ┌─────────────────────────────────────────────────────────────────┐│&#xA;│  │                    应用层安全                                   ││&#xA;│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐ ││&#xA;│  │  │ 用户认证     │  │ 权限控制     │  │ 数据加密与隐私保护       │ ││&#xA;│  │  └─────────────┘  └─────────────┘  └─────────────────────────┘ ││&#xA;│  └─────────────────────────────────────────────────────────────────┘│&#xA;│                              │                                      │&#xA;│  ┌─────────────────────────────────────────────────────────────────┐│&#xA;│  │                    传输层安全                                   ││&#xA;│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐ ││&#xA;│  │  │ HTTPS/TLS   │  │ 网络代理     │  │ API 密钥安全管理         │ ││&#xA;│  │  └─────────────┘  └─────────────┘  └─────────────────────────┘ ││&#xA;│  └─────────────────────────────────────────────────────────────────┘│&#xA;│                              │                                      │&#xA;│  ┌─────────────────────────────────────────────────────────────────┐│&#xA;│  │                    存储层安全                                   ││&#xA;│  │  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────────┐ ││&#xA;│  │  │ 本地存储加密 │  │ 配置文件保护 │  │ 会话数据访问控制         │ ││&#xA;│  │  └─────────────┘  └─────────────┘  └─────────────────────────┘ ││&#xA;│  └─────────────────────────────────────────────────────────────────┘│&#xA;└─────────────────────────────────────────────────────────────────────┘&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;数据加密机制&#34;&gt;数据加密机制&lt;/h2&gt;&#xA;&lt;h3 id=&#34;本地数据存储加密&#34;&gt;本地数据存储加密&lt;/h3&gt;&#xA;&lt;p&gt;DeepChat 对本地存储的敏感数据进行加密处理：&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat 多窗口多标签架构设计</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-multi-window-tabs/</link>
      <pubDate>Thu, 31 Jul 2025 20:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-multi-window-tabs/</guid>
      <description>&lt;h1 id=&#34;deepchat-多窗口多标签架构设计&#34;&gt;DeepChat 多窗口多标签架构设计&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;现代用户在使用 AI 工具时往往需要同时处理多个任务或主题，这就要求应用程序具备良好的多任务处理能力。DeepChat 采用了创新的多窗口+多标签架构，支持跨维度的并行多会话操作，让用户能够像使用浏览器一样使用 AI，提供非阻塞的优秀体验。本文将深入分析这一架构的设计与实现。&lt;/p&gt;&#xA;&lt;h2 id=&#34;多窗口多标签架构概述&#34;&gt;多窗口多标签架构概述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;设计理念&#34;&gt;设计理念&lt;/h3&gt;&#xA;&lt;p&gt;DeepChat 的多窗口多标签架构基于以下设计理念：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;并行处理&lt;/strong&gt; - 允许用户同时进行多个独立的对话&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;上下文隔离&lt;/strong&gt; - 每个会话都有独立的上下文，互不干扰&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;灵活组织&lt;/strong&gt; - 用户可以根据需要组织和管理会话&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;资源优化&lt;/strong&gt; - 合理管理内存和计算资源&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;架构图示&#34;&gt;架构图示&lt;/h3&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;┌─────────────────────────────────────────────────────────────────────┐&#xA;│                        DeepChat 多窗口架构                          │&#xA;├─────────────────────────────────────────────────────────────────────┤&#xA;│  ┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐  │&#xA;│  │   主窗口         │    │   子窗口A        │    │   子窗口B        │  │&#xA;│  │                 │    │                 │    │                 │  │&#xA;│  │ ┌─────────────┐ │    │ ┌─────────────┐ │    │ ┌─────────────┐ │  │&#xA;│  │ │  标签页1     │ │    │ │  标签页1     │ │    │ │  标签页1     │ │  │&#xA;│  │ ├─────────────┤ │    │ ├─────────────┤ │    │ ├─────────────┤ │  │&#xA;│  │ │  标签页2     │ │    │ │  标签页2     │ │    │ │  标签页2     │ │  │&#xA;│  │ ├─────────────┤ │    │ └─────────────┘ │    │ └─────────────┘ │  │&#xA;│  │ │  标签页3     │ │    │                 │    │                 │  │&#xA;│  │ └─────────────┘ │    │                 │    │                 │  │&#xA;│  └─────────────────┘    └─────────────────┘    └─────────────────┘  │&#xA;└─────────────────────────────────────────────────────────────────────┘&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;会话管理机制&#34;&gt;会话管理机制&lt;/h2&gt;&#xA;&lt;h3 id=&#34;会话数据结构&#34;&gt;会话数据结构&lt;/h3&gt;&#xA;&lt;p&gt;DeepChat 中的会话采用如下数据结构：&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat 搜索增强功能实现分析</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-search-enhancement/</link>
      <pubDate>Thu, 31 Jul 2025 20:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-search-enhancement/</guid>
      <description>&lt;h1 id=&#34;deepchat-搜索增强功能实现分析&#34;&gt;DeepChat 搜索增强功能实现分析&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在当今信息爆炸的时代，单纯的 AI 模型已经不能满足用户对实时、准确信息的需求。DeepChat 通过强大的搜索增强功能，将 AI 的智能与搜索引擎的实时信息相结合，为用户提供更加准确和及时的回答。本文将深入分析 DeepChat 的搜索增强功能实现机制。&lt;/p&gt;&#xA;&lt;h2 id=&#34;搜索增强的核心价值&#34;&gt;搜索增强的核心价值&lt;/h2&gt;&#xA;&lt;h3 id=&#34;为什么需要搜索增强&#34;&gt;为什么需要搜索增强？&lt;/h3&gt;&#xA;&lt;p&gt;传统的 AI 模型存在以下局限性：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;知识截止时间&lt;/strong&gt; - 大多数模型的知识截止到训练数据的时间点&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;实时信息缺失&lt;/strong&gt; - 无法获取最新的新闻、股价、天气等实时信息&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;事实准确性&lt;/strong&gt; - 模型可能会产生&amp;quot;幻觉&amp;quot;，提供不准确的信息&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;个性化限制&lt;/strong&gt; - 无法访问用户的私人数据和特定环境信息&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;搜索增强功能通过将 AI 与搜索引擎结合，有效解决了这些问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat MCP 支持深度剖析</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-mcp-support/</link>
      <pubDate>Thu, 31 Jul 2025 19:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-mcp-support/</guid>
      <description>&lt;h1 id=&#34;deepchat-mcp-支持深度剖析&#34;&gt;DeepChat MCP 支持深度剖析&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;Model Context Protocol (MCP) 是一种新兴的协议，旨在为 AI 模型提供访问外部资源、执行工具和获取提示的标准方法。DeepChat 作为先进的 AI 聊天平台，深度集成了 MCP 支持，使其能够扩展 AI 的能力，实现代码执行、网络访问等高级功能。本文将深入分析 DeepChat 中 MCP 的实现原理和应用。&lt;/p&gt;&#xA;&lt;h2 id=&#34;mcp-协议概述&#34;&gt;MCP 协议概述&lt;/h2&gt;&#xA;&lt;h3 id=&#34;什么是-mcp&#34;&gt;什么是 MCP？&lt;/h3&gt;&#xA;&lt;p&gt;Model Context Protocol (MCP) 是一种标准化协议，允许 AI 模型安全地与外部系统交互。它定义了三种核心能力：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Resources（资源）&lt;/strong&gt; - 访问外部数据和文件&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Prompts（提示）&lt;/strong&gt; - 获取和使用预定义的提示模板&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Tools（工具）&lt;/strong&gt; - 执行特定功能，如代码运行、网络请求等&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;mcp-的核心价值&#34;&gt;MCP 的核心价值&lt;/h3&gt;&#xA;&lt;p&gt;MCP 的引入解决了 AI 应用中的几个关键问题：&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat 多模型支持机制详解</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-multi-model-support/</link>
      <pubDate>Thu, 31 Jul 2025 19:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-multi-model-support/</guid>
      <description>&lt;h1 id=&#34;deepchat-多模型支持机制详解&#34;&gt;DeepChat 多模型支持机制详解&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在 AI 领域，不同的大语言模型（LLM）都有各自的优势和适用场景。DeepChat 的核心价值之一就是能够统一管理和使用各种不同的 AI 模型，包括云端模型和本地模型。本文将深入分析 DeepChat 的多模型支持机制，探讨其如何实现对众多 AI 模型提供商的统一管理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;统一接口设计与实现&#34;&gt;统一接口设计与实现&lt;/h2&gt;&#xA;&lt;h3 id=&#34;抽象层设计&#34;&gt;抽象层设计&lt;/h3&gt;&#xA;&lt;p&gt;DeepChat 采用了适配器模式来实现对不同模型提供商的支持。其核心思想是定义一个统一的接口，然后为每个模型提供商实现相应的适配器。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;┌─────────────────────────────────────────────────────────────┐&#xA;│                    统一接口架构                             │&#xA;├─────────────────────────────────────────────────────────────┤&#xA;│                    ┌──────────────┐                         │&#xA;│                    │  统一接口     │                         │&#xA;│                    │ (API抽象层)   │                         │&#xA;│                    └──────────────┘                         │&#xA;│                            │                                │&#xA;│          ┌─────────────────┼─────────────────┐              │&#xA;│          │                 │                 │              │&#xA;│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐       │&#xA;│  │ OpenAI 适配器 │  │ Gemini 适配器 │  │ Ollama 适配器 │       │&#xA;│  └──────────────┘  └──────────────┘  └──────────────┘       │&#xA;│          │                 │                 │              │&#xA;│    ┌─────▼─────┐    ┌─────▼─────┐     ┌─────▼─────┐         │&#xA;│    │ OpenAI API│    │Gemini API │     │ Ollama API│         │&#xA;│    └───────────┘    └───────────┘     └───────────┘         │&#xA;└─────────────────────────────────────────────────────────────┘&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;核心接口定义&#34;&gt;核心接口定义&lt;/h3&gt;&#xA;&lt;p&gt;DeepChat 定义了统一的模型接口，所有模型适配器都需要实现这些接口：&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat 架构设计解析：Electron 多平台实现原理</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-architecture-design/</link>
      <pubDate>Thu, 31 Jul 2025 18:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-architecture-design/</guid>
      <description>&lt;h1 id=&#34;deepchat-架构设计解析electron-多平台实现原理&#34;&gt;DeepChat 架构设计解析：Electron 多平台实现原理&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在当今快速发展的 AI 时代，跨平台应用程序的需求日益增长。DeepChat 作为一个支持多种大语言模型的 AI 聊天平台，能够在 Windows、macOS 和 Linux 三大主流操作系统上运行，这得益于其基于 Electron 的架构设计。本文将深入解析 DeepChat 的架构设计，特别是其多平台实现原理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;electron-在-deepchat-中的应用&#34;&gt;Electron 在 DeepChat 中的应用&lt;/h2&gt;&#xA;&lt;p&gt;Electron 是一个使用 Web 技术构建跨平台桌面应用程序的开源框架。DeepChat 选择 Electron 作为其基础框架，主要原因包括：&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat 跨平台实现机制详解：构建真正跨系统的 Electron 应用</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-cross-platform-implementation/</link>
      <pubDate>Thu, 31 Jul 2025 18:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-cross-platform-implementation/</guid>
      <description>&lt;h1 id=&#34;deepchat-跨平台实现机制详解构建真正跨系统的-electron-应用&#34;&gt;DeepChat 跨平台实现机制详解：构建真正跨系统的 Electron 应用&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在当今多样化的计算环境中，用户使用着不同操作系统的设备，包括 macOS、Windows 和 Linux。为了让应用程序能够触及更广泛的用户群体，跨平台支持已成为现代桌面应用开发的基本要求。DeepChat 作为一个功能丰富的 AI 聊天平台，成功实现了对三大主流操作系统的支持，为用户提供了统一而优质的使用体验。&lt;/p&gt;&#xA;&lt;p&gt;本文将深入解析 DeepChat 的跨平台实现机制，从构建系统、平台适配到发布流程，全面剖析其背后的技术细节和工程实践。&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat MCP 支持实现详解：打造强大的 AI 工具生态系统</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-mcp-implementation/</link>
      <pubDate>Thu, 31 Jul 2025 18:20:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-mcp-implementation/</guid>
      <description>&lt;h1 id=&#34;deepchat-mcp-支持实现详解打造强大的-ai-工具生态系统&#34;&gt;DeepChat MCP 支持实现详解：打造强大的 AI 工具生态系统&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;随着大语言模型（LLM）的发展，单纯的文本生成能力已经无法满足复杂应用场景的需求。Model Context Protocol（MCP）作为一种新兴的标准化协议，为 LLM 提供了访问外部工具和资源的能力，极大地扩展了 AI 应用的可能性。DeepChat 作为先进的 AI 聊天平台，对 MCP 协议提供了完整而深入的支持，本文将详细解析 DeepChat 中 MCP 的实现机制。&lt;/p&gt;&#xA;&lt;h2 id=&#34;mcp-协议简介&#34;&gt;MCP 协议简介&lt;/h2&gt;&#xA;&lt;p&gt;Model Context Protocol（MCP）是一个开放协议，旨在标准化 LLM 与外部工具、资源和提示之间的交互方式。MCP 定义了三种核心能力：&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat 多窗口多标签架构深度解析</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-multi-window-tabs-architecture/</link>
      <pubDate>Thu, 31 Jul 2025 18:15:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-multi-window-tabs-architecture/</guid>
      <description>&lt;h1 id=&#34;deepchat-多窗口多标签架构深度解析&#34;&gt;DeepChat 多窗口多标签架构深度解析&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;现代桌面应用程序普遍采用多窗口多标签的设计模式，以提升用户的工作效率和使用体验。DeepChat 作为一个功能丰富的 AI 聊天平台，实现了先进的多窗口多标签架构，支持跨窗口的标签页拖拽、独立会话管理等功能。本文将深入解析 DeepChat 的多窗口多标签架构设计，揭示其背后的技术实现原理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;传统-electron-多窗口实现&#34;&gt;传统 Electron 多窗口实现&lt;/h2&gt;&#xA;&lt;p&gt;在传统的 Electron 应用中，创建多个窗口通常有两种方式：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;BrowserWindow 方式&lt;/strong&gt; - 每个窗口都是独立的 BrowserWindow 实例&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;BrowserView 方式&lt;/strong&gt; - 在主窗口中使用 BrowserView 实现标签页效果&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这两种方式各有优缺点：&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat 多平台构建实现详解：从代码到发布</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-multi-platform-build/</link>
      <pubDate>Thu, 31 Jul 2025 18:10:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-multi-platform-build/</guid>
      <description>&lt;h1 id=&#34;deepchat-多平台构建实现详解从代码到发布&#34;&gt;DeepChat 多平台构建实现详解：从代码到发布&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在现代软件开发中，跨平台支持已成为许多应用程序的基本要求。DeepChat 作为一个开源的 AI 聊天平台，支持 Windows、macOS 和 Linux 三大主流操作系统。实现这一目标的关键在于其精心设计的构建系统。本文将深入分析 DeepChat 的多平台构建实现机制，包括构建配置、平台特定处理以及自动化发布流程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;构建系统概览&#34;&gt;构建系统概览&lt;/h2&gt;&#xA;&lt;p&gt;DeepChat 使用 &lt;a href=&#34;file:///Volumes/M20/code/docs/axfinn_blogs/node_modules/electron-builder/out/cli/cli.js#L1-L2&#34;&gt;electron-builder&lt;/a&gt; 作为其主要的构建工具，配合 &lt;a href=&#34;file:///Volumes/M20/code/docs/axfinn_blogs/node_modules/electron-vite/bin/electron-vite.js#L1-L2&#34;&gt;electron-vite&lt;/a&gt; 进行代码打包和优化。整个构建流程可以分为以下几个阶段：&lt;/p&gt;</description>
    </item>
    <item>
      <title>DeepChat 项目概览：多模型AI对话平台介绍</title>
      <link>https://axfinn.github.io/blog/2025-07/deepchat-project-overview/</link>
      <pubDate>Thu, 31 Jul 2025 18:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/deepchat-project-overview/</guid>
      <description>&lt;h1 id=&#34;deepchat-项目概览多模型ai对话平台介绍&#34;&gt;DeepChat 项目概览：多模型AI对话平台介绍&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是-deepchat&#34;&gt;什么是 DeepChat？&lt;/h2&gt;&#xA;&lt;p&gt;DeepChat 是一个功能丰富的开源 AI 聊天平台，支持多种云端和本地大语言模型，具备强大的搜索增强和工具调用能力。作为一个跨平台的 AI 助手应用程序，DeepChat 不仅支持基本的聊天功能，还提供了诸如搜索增强、工具调用和多模态交互等高级功能，让 AI 能力更加触手可及和高效。&lt;/p&gt;&#xA;&lt;p&gt;无论您是使用 OpenAI、Gemini、Anthropic 等云 API，还是本地部署的 Ollama 模型，DeepChat 都能提供流畅的用户体验。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS项目近期重要更新解析</title>
      <link>https://axfinn.github.io/blog/2025-07/nps%E9%A1%B9%E7%9B%AE%E8%BF%91%E6%9C%9F%E9%87%8D%E8%A6%81%E6%9B%B4%E6%96%B0%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Wed, 30 Jul 2025 10:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps%E9%A1%B9%E7%9B%AE%E8%BF%91%E6%9C%9F%E9%87%8D%E8%A6%81%E6%9B%B4%E6%96%B0%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;nps项目近期重要更新解析&#34;&gt;NPS项目近期重要更新解析&lt;/h2&gt;&#xA;&lt;p&gt;NPS（Network Penetration Suite）是一个轻量级、高性能、功能强大的内网穿透代理服务器，支持TCP、UDP、HTTP、HTTPS等协议。近期该项目进行了多次重要更新，本文将为您详细解析这些更新内容。&lt;/p&gt;&#xA;&lt;h2 id=&#34;最新版本概览&#34;&gt;最新版本概览&lt;/h2&gt;&#xA;&lt;p&gt;在过去的一个月中，NPS项目发布了多个版本，从v0.26.37到最新的v0.26.63，主要集中在稳定性提升、错误修复和用户体验改进等方面。&lt;/p&gt;&#xA;&lt;h3 id=&#34;核心版本更新&#34;&gt;核心版本更新&lt;/h3&gt;&#xA;&lt;h4 id=&#34;v02663---关键错误修复&#34;&gt;v0.26.63 - 关键错误修复&lt;/h4&gt;&#xA;&lt;p&gt;最新发布的v0.26.63版本重点解决了客户端和服务端握手过程中出现的EOF错误问题。这个问题可能导致连接不稳定或连接失败，特别是在网络环境较差的情况下。&lt;/p&gt;</description>
    </item>
    <item>
      <title>深入解析NPS项目近期重大更新：从代码层面看技术演进</title>
      <link>https://axfinn.github.io/blog/2025-07/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90nps%E9%A1%B9%E7%9B%AE%E8%BF%91%E6%9C%9F%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%96%B0%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E7%9C%8B%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B/</link>
      <pubDate>Wed, 30 Jul 2025 10:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90nps%E9%A1%B9%E7%9B%AE%E8%BF%91%E6%9C%9F%E9%87%8D%E5%A4%A7%E6%9B%B4%E6%96%B0%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%B1%82%E9%9D%A2%E7%9C%8B%E6%8A%80%E6%9C%AF%E6%BC%94%E8%BF%9B/</guid>
      <description>&lt;h2 id=&#34;深入解析nps项目近期重大更新从代码层面看技术演进&#34;&gt;深入解析NPS项目近期重大更新：从代码层面看技术演进&lt;/h2&gt;&#xA;&lt;p&gt;NPS（Network Penetration Suite）作为一个轻量级、高性能、功能强大的内网穿透代理服务器，近期进行了多次重要更新。本文将从源码层面深入剖析这些更新的技术细节和实现原理，帮助读者更好地理解项目的演进过程。&lt;/p&gt;&#xA;&lt;h2 id=&#34;最新版本更新概览&#34;&gt;最新版本更新概览&lt;/h2&gt;&#xA;&lt;p&gt;在过去的一个月中，NPS项目发布了多个版本，主要集中在解决客户端和服务端握手过程中的EOF错误、优化多语言支持、改进Docker部署配置等方面。其中最重要的更新是v0.26.63版本，它解决了长期困扰用户的关键连接问题。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qwen Code 实战应用与总结</title>
      <link>https://axfinn.github.io/blog/2025-07/qwen-code-practical-applications-and-summary/</link>
      <pubDate>Wed, 23 Jul 2025 16:10:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/qwen-code-practical-applications-and-summary/</guid>
      <description>&lt;h1 id=&#34;qwen-code-实战应用与总结&#34;&gt;Qwen Code 实战应用与总结&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;经过前面七篇文章的详细介绍，我们已经全面了解了 Qwen Code 项目的各个方面，从基本概念到核心实现细节。在本文中，我们将通过实际应用案例来展示 Qwen Code 的强大功能，并对整个系列进行总结。&lt;/p&gt;&#xA;&lt;h2 id=&#34;实战应用案例&#34;&gt;实战应用案例&lt;/h2&gt;&#xA;&lt;h3 id=&#34;案例一快速理解开源项目&#34;&gt;案例一：快速理解开源项目&lt;/h3&gt;&#xA;&lt;p&gt;假设我们需要快速理解一个复杂的开源项目，比如 Redux。我们可以使用 Qwen Code 来帮助我们：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 启动 Qwen Code&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;qwen-code&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 然后输入以下指令：&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# &amp;#34;请帮我分析 Redux 项目的结构，特别是它的核心概念和实现原理&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;Qwen Code 会执行以下操作：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;list_directory&lt;/code&gt; 工具查看项目结构&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;read_file&lt;/code&gt; 工具读取关键文件（如 README.md、核心源文件）&lt;/li&gt;&#xA;&lt;li&gt;使用 &lt;code&gt;search_file_content&lt;/code&gt; 工具搜索特定概念的实现&lt;/li&gt;&#xA;&lt;li&gt;综合分析后给出详细的解释&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;案例二自动化代码审查&#34;&gt;案例二：自动化代码审查&lt;/h3&gt;&#xA;&lt;p&gt;我们可以使用 Qwen Code 来自动化代码审查流程：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qwen Code 开发指南</title>
      <link>https://axfinn.github.io/blog/2025-07/qwen-code-development-guide/</link>
      <pubDate>Wed, 23 Jul 2025 16:05:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/qwen-code-development-guide/</guid>
      <description>&lt;h1 id=&#34;qwen-code-开发指南&#34;&gt;Qwen Code 开发指南&lt;/h1&gt;&#xA;&lt;h2 id=&#34;开发环境设置&#34;&gt;开发环境设置&lt;/h2&gt;&#xA;&lt;h3 id=&#34;系统要求&#34;&gt;系统要求&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;Node.js 20+&lt;/strong&gt;：项目需要 Node.js 20 或更高版本&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;npm 8+&lt;/strong&gt;：推荐使用 npm 8 或更高版本&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Git&lt;/strong&gt;：用于版本控制&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;克隆项目&#34;&gt;克隆项目&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;git clone git@github.com:axfinn/qwen-code.git&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;cd&lt;/span&gt; qwen-code&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;安装依赖&#34;&gt;安装依赖&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;npm install&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这将安装所有必要的依赖项，包括开发依赖。&lt;/p&gt;&#xA;&lt;h2 id=&#34;项目结构回顾&#34;&gt;项目结构回顾&lt;/h2&gt;&#xA;&lt;p&gt;Qwen Code 采用 monorepo 结构，使用 npm workspaces 管理多个包：&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;qwen-code/&#xA;├── packages/&#xA;│   ├── cli/          # CLI 工具&#xA;│   ├── core/         # 核心功能&#xA;│   └── ...           # 其他包&#xA;├── docs/             # 文档&#xA;├── examples/         # 示例&#xA;├── tests/            # 测试&#xA;└── ...&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h2 id=&#34;开发工作流&#34;&gt;开发工作流&lt;/h2&gt;&#xA;&lt;h3 id=&#34;构建项目&#34;&gt;构建项目&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 构建所有包&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;npm run build&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 构建特定包&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;npm run build --workspace&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;@qwen-code/cli&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;运行测试&#34;&gt;运行测试&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 运行所有测试&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;npm &lt;span class=&#34;nb&#34;&gt;test&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 运行单元测试&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;npm run test:unit&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 运行集成测试&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;npm run test:integration&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;代码检查&#34;&gt;代码检查&lt;/h3&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 运行 ESLint&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;npm run lint&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 运行 TypeScript 类型检查&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;npm run typecheck&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;# 格式化代码&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;npm run format&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;完整预检&#34;&gt;完整预检&lt;/h3&gt;&#xA;&lt;p&gt;在提交代码前，运行完整的预检流程：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qwen Code 核心代码实现细节深度解读</title>
      <link>https://axfinn.github.io/blog/2025-07/qwen-code-core-implementation-details/</link>
      <pubDate>Wed, 23 Jul 2025 16:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/qwen-code-core-implementation-details/</guid>
      <description>&lt;h1 id=&#34;qwen-code-核心代码实现细节深度解读&#34;&gt;Qwen Code 核心代码实现细节深度解读&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在前几篇文章中，我们已经对 Qwen Code 的整体架构和实现框架进行了详细分析。现在，我们将深入到代码层面，解读 Qwen Code 的核心实现细节。通过分析关键代码片段，我们可以更好地理解 Qwen Code 的工作原理和设计思想。&lt;/p&gt;&#xA;&lt;h2 id=&#34;cli-入口点分析&#34;&gt;CLI 入口点分析&lt;/h2&gt;&#xA;&lt;h3 id=&#34;主程序启动&#34;&gt;主程序启动&lt;/h3&gt;&#xA;&lt;p&gt;CLI 的入口点位于 &lt;code&gt;packages/cli/index.ts&lt;/code&gt;：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-typescript&#34; data-lang=&#34;typescript&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;err&#34;&gt;#&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;!&lt;/span&gt;&lt;span class=&#34;err&#34;&gt;/usr/bin/env node&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;./src/gemini.js&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kr&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;kr&#34;&gt;from&lt;/span&gt; &lt;span class=&#34;s1&#34;&gt;&amp;#39;./src/gemini.js&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;// --- Global Entry Point ---&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;c1&#34;&gt;&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;main&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;().&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;catch&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;((&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;o&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s1&#34;&gt;&amp;#39;An unexpected critical error occurred:&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;k&#34;&gt;if&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;instanceof&lt;/span&gt; &lt;span class=&#34;nb&#34;&gt;Error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;stack&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt; &lt;span class=&#34;k&#34;&gt;else&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;console&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nb&#34;&gt;String&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;error&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;));&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;  &lt;span class=&#34;nx&#34;&gt;process&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;exit&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;mi&#34;&gt;1&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;);&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;});&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这段代码做了几件重要的事情：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;导入主模块 &lt;code&gt;gemini.js&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;调用 &lt;code&gt;main()&lt;/code&gt; 函数启动应用&lt;/li&gt;&#xA;&lt;li&gt;实现全局错误处理，确保任何未捕获的异常都能被妥善处理&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;CLI 启动流程可以用下图表示：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qwen Code 实现框架深度解析</title>
      <link>https://axfinn.github.io/blog/2025-07/qwen-code-implementation-framework/</link>
      <pubDate>Wed, 23 Jul 2025 15:55:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/qwen-code-implementation-framework/</guid>
      <description>&lt;h1 id=&#34;qwen-code-实现框架深度解析&#34;&gt;Qwen Code 实现框架深度解析&lt;/h1&gt;&#xA;&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;Qwen Code 是一个基于 AI 的命令行工具，它将大型语言模型的能力与本地开发环境相结合。为了实现这一目标，Qwen Code 采用了复杂而精巧的实现框架，涉及多个技术领域。本文将深入解析 Qwen Code 的实现框架，帮助读者理解其内部工作机制。&lt;/p&gt;&#xA;&lt;h2 id=&#34;整体架构&#34;&gt;整体架构&lt;/h2&gt;&#xA;&lt;p&gt;Qwen Code 的整体架构可以分为以下几个主要层次：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;用户接口层&lt;/strong&gt;：提供命令行交互界面&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;核心逻辑层&lt;/strong&gt;：处理用户请求和 AI 模型交互&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;工具执行层&lt;/strong&gt;：执行各种本地操作工具&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;模型接口层&lt;/strong&gt;：与 Qwen 模型进行通信&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;安全管理层&lt;/strong&gt;：确保操作的安全性&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;┌─────────────────────────────────────┐&#xA;│           用户接口层                 │&#xA;│         (CLI 界面)                  │&#xA;├─────────────────────────────────────┤&#xA;│           核心逻辑层                 │&#xA;│    (请求处理、响应生成)              │&#xA;├─────────────────────────────────────┤&#xA;│          工具执行层                  │&#xA;│  (文件系统、网络、命令执行等工具)     │&#xA;├─────────────────────────────────────┤&#xA;│          模型接口层                  │&#xA;│      (与 Qwen 模型通信)              │&#xA;├─────────────────────────────────────┤&#xA;│          安全管理层                  │&#xA;│    (权限控制、沙箱隔离等)            │&#xA;└─────────────────────────────────────┘&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了更直观地理解整体架构，我们可以用 Mermaid 绘制一个架构图：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qwen Code 项目框架详解</title>
      <link>https://axfinn.github.io/blog/2025-07/qwen-code-project-structure/</link>
      <pubDate>Wed, 23 Jul 2025 15:50:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/qwen-code-project-structure/</guid>
      <description>&lt;h1 id=&#34;qwen-code-项目框架详解&#34;&gt;Qwen Code 项目框架详解&lt;/h1&gt;&#xA;&lt;h2 id=&#34;项目概述&#34;&gt;项目概述&lt;/h2&gt;&#xA;&lt;p&gt;Qwen Code 采用现代化的软件工程实践，使用 TypeScript 编写，基于 monorepo 结构管理多个包。项目结构清晰，便于维护和扩展。&lt;/p&gt;&#xA;&lt;h2 id=&#34;项目结构&#34;&gt;项目结构&lt;/h2&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;qwen-code/&#xA;├── .github/                  # GitHub 相关配置&#xA;│   └── workflows/            # CI/CD 工作流&#xA;├── docs/                     # 项目文档&#xA;│   ├── tools/                # 工具文档&#xA;│   └── ...                   # 其他文档&#xA;├── examples/                 # 使用示例&#xA;├── integration-tests/        # 集成测试&#xA;├── packages/                 # 核心包&#xA;│   ├── cli/                  # CLI 工具&#xA;│   ├── core/                 # 核心功能&#xA;│   └── ...                   # 其他包&#xA;├── scripts/                  # 构建和辅助脚本&#xA;├── tests/                    # 单元测试&#xA;├── .eslintrc.js              # ESLint 配置&#xA;├── .gitignore                # Git 忽略文件&#xA;├── .npmrc                    # npm 配置&#xA;├── Dockerfile                # Docker 配置&#xA;├── Makefile                  # Makefile 脚本&#xA;├── README.md                 # 项目说明&#xA;├── package.json              # 项目配置&#xA;└── tsconfig.json             # TypeScript 配置&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;为了更直观地理解项目结构，我们可以用 Mermaid 绘制一个图表：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qwen Code CLI 使用详解</title>
      <link>https://axfinn.github.io/blog/2025-07/qwen-code-cli-usage/</link>
      <pubDate>Wed, 23 Jul 2025 15:45:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/qwen-code-cli-usage/</guid>
      <description>&lt;h1 id=&#34;qwen-code-cli-使用详解&#34;&gt;Qwen Code CLI 使用详解&lt;/h1&gt;&#xA;&lt;h2 id=&#34;cli-入门&#34;&gt;CLI 入门&lt;/h2&gt;&#xA;&lt;p&gt;Qwen Code 是一个功能强大的命令行 AI 工作流工具，为开发者提供了一种全新的与代码交互的方式。通过 CLI，用户可以与 AI 进行对话，执行各种编程任务。&lt;/p&gt;&#xA;&lt;h3 id=&#34;安装&#34;&gt;安装&lt;/h3&gt;&#xA;&lt;p&gt;确保您已经安装了 Node.js 20+ 版本，然后通过 npm 安装 Qwen Code：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;npm install -g @qwen-code/qwen-code&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;基本使用&#34;&gt;基本使用&lt;/h3&gt;&#xA;&lt;p&gt;安装完成后，您可以通过以下命令启动 Qwen Code：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;qwen-code&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;这将启动交互式 CLI 会话，您可以直接与 AI 进行对话。&lt;/p&gt;&#xA;&lt;h3 id=&#34;非交互式使用&#34;&gt;非交互式使用&lt;/h3&gt;&#xA;&lt;p&gt;您也可以通过管道或重定向将输入传递给 Qwen Code：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;echo&lt;/span&gt; &lt;span class=&#34;s2&#34;&gt;&amp;#34;帮我生成一个 React 组件&amp;#34;&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;|&lt;/span&gt; qwen-code&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h2 id=&#34;cli-入口实现&#34;&gt;CLI 入口实现&lt;/h2&gt;&#xA;&lt;p&gt;Qwen Code 的 CLI 入口是一个基于 React 和 Ink 构建的命令行应用程序。主要特性包括：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qwen Code 工具详解</title>
      <link>https://axfinn.github.io/blog/2025-07/qwen-code-tools-detailed/</link>
      <pubDate>Wed, 23 Jul 2025 15:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/qwen-code-tools-detailed/</guid>
      <description>&lt;h1 id=&#34;qwen-code-工具详解&#34;&gt;Qwen Code 工具详解&lt;/h1&gt;&#xA;&lt;h2 id=&#34;工具概览&#34;&gt;工具概览&lt;/h2&gt;&#xA;&lt;p&gt;Qwen Code 提供了一套丰富的工具集，允许 AI 模型与本地环境进行交互、执行命令、访问文件和执行各种操作。这些工具通过确认提示和沙箱机制确保安全性。&lt;/p&gt;&#xA;&lt;p&gt;工具集的分类可以用下图表示：&lt;/p&gt;&#xA;&lt;div class=&#34;mermaid&#34;&gt;&#xA;&#xA;graph TD&#xA;    A[Qwen Code 工具集] --&gt; B[文件系统工具]&#xA;    A --&gt; C[网络工具]&#xA;    A --&gt; D[其他工具]&#xA;    &#xA;    B --&gt; B1[list_directory]&#xA;    B --&gt; B2[read_file]&#xA;    B --&gt; B3[write_file]&#xA;    B --&gt; B4[glob]&#xA;    B --&gt; B5[search_file_content]&#xA;    B --&gt; B6[replace]&#xA;    &#xA;    C --&gt; C1[google_web_search]&#xA;    C --&gt; C2[web_fetch]&#xA;    &#xA;    D --&gt; D1[save_memory]&#xA;    D --&gt; D2[run_shell_command]&#xA;    D --&gt; D3[MCP 服务器工具]&#xA;&#xA;&lt;/div&gt;&#xA;&lt;h2 id=&#34;文件系统工具&#34;&gt;文件系统工具&lt;/h2&gt;&#xA;&lt;p&gt;Qwen Code 提供了完整的文件系统操作工具：&lt;/p&gt;&#xA;&lt;h3 id=&#34;list_directory列出目录内容&#34;&gt;&lt;code&gt;list_directory&lt;/code&gt;：列出目录内容&lt;/h3&gt;&#xA;&lt;p&gt;参数：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;path&lt;/code&gt; (string, required): 要列出的目录的绝对路径&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;ignore&lt;/code&gt; (array, optional): 要忽略的 glob 模式列表&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;respect_git_ignore&lt;/code&gt; (boolean, optional): 是否遵循 .gitignore 模式，默认为 true&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;功能：显示指定目录下的文件和子目录&lt;/p&gt;</description>
    </item>
    <item>
      <title>Qwen Code 项目概览</title>
      <link>https://axfinn.github.io/blog/2025-07/qwen-code-project-overview/</link>
      <pubDate>Wed, 23 Jul 2025 15:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/qwen-code-project-overview/</guid>
      <description>&lt;h1 id=&#34;qwen-code-项目概览&#34;&gt;Qwen Code 项目概览&lt;/h1&gt;&#xA;&lt;h2 id=&#34;什么是-qwen-code&#34;&gt;什么是 Qwen Code？&lt;/h2&gt;&#xA;&lt;p&gt;Qwen Code 是一个基于 Gemini CLI 改造的命令行 AI 工作流工具，专为 Qwen3-Coder 模型优化，具有增强的解析器和工具支持。该项目的主要目标是为开发者提供一个强大的命令行界面，让他们能够利用 AI 的能力来完成各种编程任务。&lt;/p&gt;&#xA;&lt;pre tabindex=&#34;0&#34;&gt;&lt;code&gt;┌─────────────────────────────────────┐&#xA;│           Qwen Code 架构            │&#xA;├─────────────────────────────────────┤&#xA;│  ┌─────────────┐  ┌──────────────┐ │&#xA;│  │   CLI 界面   │  │  核心引擎     │ │&#xA;│  └─────────────┘  └──────────────┘ │&#xA;│        │               │           │&#xA;│        ▼               ▼           │&#xA;│  ┌─────────────┐  ┌──────────────┐ │&#xA;│  │  用户输入    │  │  AI 模型接口  │ │&#xA;│  └─────────────┘  └──────────────┘ │&#xA;│        │               │           │&#xA;│        ▼               ▼           │&#xA;│  ┌───────────────────────────────┐ │&#xA;│  │        工具执行层              │ │&#xA;│  │  - 文件系统操作                │ │&#xA;│  │  - 网络请求                   │ │&#xA;│  │  - 命令执行                   │ │&#xA;│  │  - 内存管理                   │ │&#xA;│  └───────────────────────────────┘ │&#xA;└─────────────────────────────────────┘&#xA;&lt;/code&gt;&lt;/pre&gt;&lt;h3 id=&#34;核心特性&#34;&gt;核心特性&lt;/h3&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;超越上下文限制的代码理解和编辑&lt;/strong&gt;：Qwen Code 可以处理大型代码库，不受传统模型上下文长度的限制。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;工作流自动化&lt;/strong&gt;：支持复杂的开发任务自动化，提高开发效率。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;增强的解析器&lt;/strong&gt;：改进了对代码结构的理解能力，能够更准确地解析和处理代码。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;丰富的工具集&lt;/strong&gt;：提供多种工具，包括文件系统访问、网络搜索、多文件处理等。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h3 id=&#34;安装要求&#34;&gt;安装要求&lt;/h3&gt;&#xA;&lt;p&gt;Qwen Code 需要 Node.js 20+ 版本。可以通过 npm 或从源代码安装：&lt;/p&gt;</description>
    </item>
    <item>
      <title>使用Qwen Code快速实现动态背景图功能</title>
      <link>https://axfinn.github.io/blog/2025-07/%E4%BD%BF%E7%94%A8qwen-code%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF%E5%9B%BE%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Wed, 23 Jul 2025 00:00:00 +0000</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/%E4%BD%BF%E7%94%A8qwen-code%E5%BF%AB%E9%80%9F%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E8%83%8C%E6%99%AF%E5%9B%BE%E5%8A%9F%E8%83%BD/</guid>
      <description>&lt;p&gt;在现代网站设计中，动态背景图已成为提升用户体验的重要元素之一。本文将详细介绍如何使用Qwen Code智能助手快速实现一个功能丰富的动态背景图系统。&lt;/p&gt;&#xA;&lt;h2 id=&#34;需求分析&#34;&gt;需求分析&lt;/h2&gt;&#xA;&lt;p&gt;在开始编码之前，我们需要明确要实现的功能：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;背景图片自动轮换（使用外部图片服务）&lt;/li&gt;&#xA;&lt;li&gt;可配置的轮换间隔时间&lt;/li&gt;&#xA;&lt;li&gt;可调节的过渡动画时间&lt;/li&gt;&#xA;&lt;li&gt;手动切换上一张/下一张背景图&lt;/li&gt;&#xA;&lt;li&gt;控制面板，可展开/收起进行设置&lt;/li&gt;&#xA;&lt;li&gt;实时状态显示&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;h2 id=&#34;使用qwen-code实现过程&#34;&gt;使用Qwen Code实现过程&lt;/h2&gt;&#xA;&lt;h3 id=&#34;1-项目分析&#34;&gt;1. 项目分析&lt;/h3&gt;&#xA;&lt;p&gt;首先，我们让Qwen Code分析项目结构，了解Hugo网站的组织方式：&lt;/p&gt;</description>
    </item>
    <item>
      <title>Git 学习与详细使用指南</title>
      <link>https://axfinn.github.io/blog/2025-07/git-learning-and-usage-guide/</link>
      <pubDate>Sat, 19 Jul 2025 11:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/git-learning-and-usage-guide/</guid>
      <description>&lt;h1 id=&#34;git-学习与详细使用指南&#34;&gt;Git 学习与详细使用指南&lt;/h1&gt;&#xA;&lt;p&gt;Git 是目前世界上最流行、最先进的分布式版本控制系统。它能够高效地管理项目代码，记录每一次修改，并允许多人协作开发。无论你是个人开发者还是团队成员，掌握 Git 都是一项必备技能。&lt;/p&gt;&#xA;&lt;p&gt;本文将从 Git 的基本概念入手，逐步深入到常用命令、分支管理、远程协作，并提供一些高级技巧和参考资源，帮助你全面掌握 Git。&lt;/p&gt;&#xA;&lt;h2 id=&#34;1-git-基础概念&#34;&gt;1. Git 基础概念&lt;/h2&gt;&#xA;&lt;p&gt;在深入学习 Git 命令之前，理解以下核心概念至关重要：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;版本控制系统 (VCS)&lt;/strong&gt;: 记录文件内容变化，以便将来查阅特定版本修订情况的系统。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;分布式版本控制系统 (DVCS)&lt;/strong&gt;: 每个开发者都拥有完整的代码仓库副本，无需依赖中央服务器即可进行大部分操作。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;仓库 (Repository)&lt;/strong&gt;: 存储项目所有文件和历史记录的��方。分为本地仓库和远程仓库。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;工作区 (Working Directory)&lt;/strong&gt;: 你在电脑上实际操作的目录，包含项目文件。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;暂存区 (Staging Area / Index)&lt;/strong&gt;: 一个临时区域，用于存放你即将提交（commit）的更改。你可以选择性地将工作区的修改添加到暂存区。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;提交 (Commit)&lt;/strong&gt;: 将暂存区的更改永久保存到本地仓库的历史记录中。每次提交都会生成一个唯一的 SHA-1 值作为标识。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;分支 (Branch)&lt;/strong&gt;: Git 中最强大的功能之一。它允许你在不影响主线开发的情况下，独立地进行新功能开发或 bug 修复。每个分支都是一个独立的开发线。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HEAD&lt;/strong&gt;: 指向当前所在分支的指针。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;2-git-安装与配置&#34;&gt;2. Git 安装与配置&lt;/h2&gt;&#xA;&lt;h3 id=&#34;21-安装-git&#34;&gt;2.1 安装 Git&lt;/h3&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;macOS&lt;/strong&gt;: &lt;code&gt;brew install git&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Linux (Debian/Ubuntu)&lt;/strong&gt;: &lt;code&gt;sudo apt-get install git&lt;/code&gt;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Windows&lt;/strong&gt;: 从 &lt;a href=&#34;https://git-scm.com/download/win&#34;&gt;Git 官方网站&lt;/a&gt; 下载安装包。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;安装完成后，在终端输入 &lt;code&gt;git --version&lt;/code&gt; 验证是否成功。&lt;/p&gt;</description>
    </item>
    <item>
      <title>Hotel 项目：远程服务器部署指南</title>
      <link>https://axfinn.github.io/blog/2025-07/hotel-project-remote-deployment-guide/</link>
      <pubDate>Sat, 19 Jul 2025 11:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/hotel-project-remote-deployment-guide/</guid>
      <description>&lt;h1 id=&#34;hotel-项目远程服务器部署指南&#34;&gt;Hotel 项目：远程服务器部署指南&lt;/h1&gt;&#xA;&lt;p&gt;本文档提供了将 &lt;code&gt;hotel&lt;/code&gt; 酒店管理系统部署到远程服务器的详细步骤，主要通过 Docker 进行。&lt;/p&gt;&#xA;&lt;h2 id=&#34;前提条件&#34;&gt;前提条件&lt;/h2&gt;&#xA;&lt;p&gt;在开始之前，请确保您的远程服务器已安装以下工具：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Git&lt;/strong&gt;: 用于克隆项目仓库。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;Docker&lt;/strong&gt;: 用于构建和运行容器化应用程序。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;SSH 访问&lt;/strong&gt;: 用于连接到您的远程服务器。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;部署步骤&#34;&gt;部署步骤&lt;/h2&gt;&#xA;&lt;p&gt;请按照以下步骤在您的远程服务器上部署 &lt;code&gt;hotel&lt;/code&gt; 项目：&lt;/p&gt;&#xA;&lt;h3 id=&#34;1-连接到您的远程服务器&#34;&gt;1. 连接到您的远程服务器&lt;/h3&gt;&#xA;&lt;p&gt;使用 SSH 连接到您的远程服务器：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;ssh your_username@your_server_ip&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;h3 id=&#34;2-克隆仓库&#34;&gt;2. 克隆仓库&lt;/h3&gt;&#xA;&lt;p&gt;导航到您希望部署的目录（例如，&lt;code&gt;/opt/apps/&lt;/code&gt;），然后克隆 &lt;code&gt;hotel&lt;/code&gt; 项目仓库：&lt;/p&gt;</description>
    </item>
    <item>
      <title>从零到一：用 Flask &#43; SQLite 打造一个轻量级酒店管理系统（前后端详解）</title>
      <link>https://axfinn.github.io/blog/2025-07/flask-sqlite-hotel-system-tutorial/</link>
      <pubDate>Sat, 19 Jul 2025 11:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/flask-sqlite-hotel-system-tutorial/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;对于许多编程初学者来说，理论知识和实际项目之间总有一道鸿沟。今天，我将带领大家跨越这道鸿沟，通过一个真实的项目——&lt;code&gt;hotel&lt;/code&gt; 轻量级酒店管理系统，来学习如何将技术应用到实践中。&lt;/p&gt;&#xA;&lt;p&gt;这个项目非常适合初学者，它功能完整、代码清晰，并且覆盖了 Web 开发的方方面面：从后端逻辑、数据库设计，到前端页面渲染和用户交互。最棒的是，它还支持 Docker 一键部署！&lt;/p&gt;&#xA;&lt;p&gt;&lt;strong&gt;项目地址&lt;/strong&gt;: &lt;a href=&#34;git@github.com:axfinn/hotel.git&#34;&gt;git@github.com:axfinn/hotel.git&lt;/a&gt;&lt;/p&gt;&#xA;&lt;p&gt;我将从环境搭建开始，详细剖析前后端代码，让你不仅能看懂，更能学会如何构建一个属于自己的 Web 应用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>从零到一：使用 Hugo 和 GitHub Pages 搭建个人博客</title>
      <link>https://axfinn.github.io/blog/2025-07/%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</link>
      <pubDate>Sat, 19 Jul 2025 00:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/%E4%BB%8E%E9%9B%B6%E5%88%B0%E4%B8%80%E4%BD%BF%E7%94%A8-hugo-%E5%92%8C-github-pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</guid>
      <description>&lt;h2 id=&#34;前言&#34;&gt;前言&lt;/h2&gt;&#xA;&lt;p&gt;拥有一个个人博客是分享知识、记录学习和展示作品的绝佳方式。本文将详细介绍如何使用强大的静态网站生成器 Hugo 和免费的 GitHub Pages 服务，从零开始搭建一个属于你自己的、功能完善且高度可定制的个人博客。&lt;/p&gt;&#xA;&lt;h2 id=&#34;为什么选择-hugo-和-github-pages&#34;&gt;为什么选择 Hugo 和 GitHub Pages？&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;Hugo&lt;/strong&gt;: Go 语言编写的静态网站生成器，以其惊人的构建速度和灵活性而闻名。它拥有丰富的主题和强大的功能，让你可以专注于内容创作。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;GitHub Pages&lt;/strong&gt;: GitHub 提供的免费静态网站托管服务。它与 Git 无缝集成，非常适合托管个人博客、项目文档等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;准备工作&#34;&gt;准备工作&lt;/h2&gt;&#xA;&lt;p&gt;在开始之前，请确保你的电脑上已经安装了以下软件：&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 全景解析（完结）：揭秘功能强大的 Web 管理界面</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E5%85%A8%E6%99%AF%E8%A7%A3%E6%9E%90%E5%AE%8C%E7%BB%93%E6%8F%AD%E7%A7%98%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84-web-%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2/</link>
      <pubDate>Fri, 18 Jul 2025 19:15:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E5%85%A8%E6%99%AF%E8%A7%A3%E6%9E%90%E5%AE%8C%E7%BB%93%E6%8F%AD%E7%A7%98%E5%8A%9F%E8%83%BD%E5%BC%BA%E5%A4%A7%E7%9A%84-web-%E7%AE%A1%E7%90%86%E7%95%8C%E9%9D%A2/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;一个工具的强大与否，不仅取决于其核心功能的性能与稳定，也取决于其易用性。NPS 之所以广受欢迎，除了其强大的穿透能力外，一个直观、功能全面的 Web 管理界面功不可没。用户无需编辑复杂的配置文件，只需在浏览器上进行简单的点击操作，就能完成客户端管理、隧道配置、域名绑定等所有操作。在本系列文章的最后一篇，我们将深入 &lt;code&gt;nps/web&lt;/code&gt; 目录，揭秘这个基于 Beego 框架构建的 Web 管理界面是如何与 NPS 核心服务无缝集成，为用户提供流畅体验的。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;技术选型beego-框架&#34;&gt;技术选型：Beego 框架&lt;/h2&gt;&#xA;&lt;p&gt;NPS 的 Web 后端采用了 &lt;a href=&#34;https://github.com/beego/beego&#34;&gt;Beego&lt;/a&gt;，一个用 Go 语言编写的高性能 Web 框架。Beego 遵循 MVC（Model-View-Controller）设计模式，提供了路由、模板引擎、ORM、Session 管理等一整套 Web 开发所需的功能，这使得开发者可以快速构建起一个功能完善的 Web 应用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 核心探秘：配置加载与数据持久化</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E6%A0%B8%E5%BF%83%E6%8E%A2%E7%A7%98%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</link>
      <pubDate>Fri, 18 Jul 2025 19:10:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E6%A0%B8%E5%BF%83%E6%8E%A2%E7%A7%98%E9%85%8D%E7%BD%AE%E5%8A%A0%E8%BD%BD%E4%B8%8E%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;一个稳定可靠的服务，离不开健全的配置管理和数据持久化机制。NPS 作为一个需要长期运行的内网穿透服务器，必须能够加载启动配置、在运行时动态修改配置，并在服务重启后恢复所有任务和客户端信息。这一切都由 &lt;code&gt;nps/file&lt;/code&gt; 目录下的代码实现。本篇文章将深入这一模块，剖析 NPS 是如何通过简单的 JSON 文件，构建出一个轻量级且高效的“数据库”，并实现对客户端、隧道、主机等所有配置的增删改查和持久化存储。&lt;/p&gt;&#xA;&lt;hr&gt;&#xA;&lt;h2 id=&#34;filegonps-的数据中枢&#34;&gt;&lt;code&gt;file.go&lt;/code&gt;：NPS 的数据中枢&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;nps/file&lt;/code&gt; 目录的核心是 &lt;code&gt;file.go&lt;/code&gt; 文件，它定义了 NPS 的数据模型和所有数据操作的接口。NPS 并未采用传统的关系型数据库或 NoSQL 数据库，而是选择使用 JSON 文件作为其数据存储后端，这使得 NPS 非常轻量、易于部署和迁移。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 客户端深度解析：健康检查与动态注册</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C/</link>
      <pubDate>Fri, 18 Jul 2025 19:05:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90%E5%81%A5%E5%BA%B7%E6%A3%80%E6%9F%A5%E4%B8%8E%E5%8A%A8%E6%80%81%E6%B3%A8%E5%86%8C/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在前面的文章中，我们已经剖析了 NPS 客户端的核心逻辑（&lt;code&gt;client.go&lt;/code&gt;）和控制模块（&lt;code&gt;control.go&lt;/code&gt;）。我们了解到客户端如何与服务端建立连接、如何通过多路复用隧道转发流量，以及如何从配置文件启动。然而，一个成熟的系统不仅需要核心功能，还需要完善的辅助机制来保证其在复杂多变的生产环境中的稳定性和灵活性。本篇文章将深入 NPS 客户端的另外两个重要文件：&lt;code&gt;nps/client/health.go&lt;/code&gt; 和 &lt;code&gt;nps/client/register.go&lt;/code&gt;，探讨 NPS 是如何实现对后端服务的健康检查以及支持客户端动态注册的。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 核心组件：深入剖析 Bridge 模块</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-bridge-%E6%A8%A1%E5%9D%97/</link>
      <pubDate>Fri, 18 Jul 2025 19:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6%E6%B7%B1%E5%85%A5%E5%89%96%E6%9E%90-bridge-%E6%A8%A1%E5%9D%97/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在 NPS 的服务端架构中，&lt;code&gt;proxy&lt;/code&gt; 模块负责监听公网端口并处理各种协议的流量，而 &lt;code&gt;client&lt;/code&gt; 模块则在内网中连接本地服务。那么，当一个公网请求到达 &lt;code&gt;proxy&lt;/code&gt; 模块后，它是如何精确地找到对应的内网客户端，并与之建立一条数据通道的呢？答案就是 &lt;strong&gt;&lt;code&gt;Bridge&lt;/code&gt; 模块&lt;/strong&gt;。&lt;code&gt;Bridge&lt;/code&gt; 是 NPS 服务端的核心枢纽，它负责维护所有客户端的长连接，并在此之上建立控制和数据隧道，是整个 NPS 体系的“交通总指挥”。&lt;/p&gt;&#xA;&lt;h2 id=&#34;bridge-结构体通信枢纽的核心&#34;&gt;&lt;code&gt;Bridge&lt;/code&gt; 结构体：通信枢纽的核心&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;bridge.go&lt;/code&gt; 文件首先定义了 &lt;code&gt;Bridge&lt;/code&gt; 结构体，它包含了 &lt;code&gt;Bridge&lt;/code&gt; 模块运行所需的所有关键信息：&lt;/p&gt;</description>
    </item>
    <item>
      <title>One Test</title>
      <link>https://axfinn.github.io/blog/2025-07/one-test/</link>
      <pubDate>Fri, 18 Jul 2025 18:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/one-test/</guid>
      <description>This is an example of adding an intro picture to the post.</description>
    </item>
    <item>
      <title>一句话命令</title>
      <link>https://axfinn.github.io/blog/2025-07/%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%91%BD%E4%BB%A4/</link>
      <pubDate>Fri, 18 Jul 2025 18:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/%E4%B8%80%E5%8F%A5%E8%AF%9D%E5%91%BD%E4%BB%A4/</guid>
      <description>&lt;h2 id=&#34;常用一句话命令&#34;&gt;常用一句话命令&lt;/h2&gt;&#xA;&lt;h3 id=&#34;网络&#34;&gt;网络&lt;/h3&gt;&#xA;&lt;p&gt;监听端口：&lt;code&gt;netstat -tnple&lt;/code&gt; ，如果没有安装软件包 &lt;code&gt;net-tools&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;linux系统排查&#34;&gt;LINUX系统排查&lt;/h3&gt;&#xA;&lt;h3 id=&#34;快速下载&#34;&gt;快速下载&lt;/h3&gt;&#xA;&lt;h3 id=&#34;数据库&#34;&gt;数据库&lt;/h3&gt;&#xA;&lt;p&gt;数据库备份：&lt;/p&gt;&#xA;&lt;p&gt;备份脚本：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-bash&#34; data-lang=&#34;bash&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;#!/bin//bash&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;cp&#34;&gt;&lt;/span&gt;&lt;span class=&#34;c1&#34;&gt;#&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;NOW&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;$(&lt;/span&gt;date +&lt;span class=&#34;s2&#34;&gt;&amp;#34;%Y-%m-%d&amp;#34;&lt;/span&gt;&lt;span class=&#34;k&#34;&gt;)&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;#34;&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;DATA_DIR&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;backup&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;nb&#34;&gt;export&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;DATA_DATABASE&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;dress&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;mysqldump --opt -uroot  -p&lt;span class=&#34;s1&#34;&gt;&amp;#39;P@ssw0rd&amp;#39;&lt;/span&gt; -h&lt;span class=&#34;s1&#34;&gt;&amp;#39;h2.jaxiu.cn&amp;#39;&lt;/span&gt; &lt;span class=&#34;nv&#34;&gt;$DATA_DATABASE&lt;/span&gt; &amp;gt; &lt;span class=&#34;nv&#34;&gt;$DATA_DIR&lt;/span&gt;/&lt;span class=&#34;si&#34;&gt;${&lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;DATA_DATABASE&lt;/span&gt;&lt;span class=&#34;si&#34;&gt;}&lt;/span&gt;_&lt;span class=&#34;nv&#34;&gt;$NOW&lt;/span&gt;.sql&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;p&gt;一句话 docker 命令：&#xA;&lt;code&gt;docker run -ti --name mysql_dump -v /root/x/scripts/mysql_backup.sh:/mysql_backup.sh -v /root/x/scripts/backup:/backup:rw mysql:5.7.16 ./mysql_backup.sh&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;删除已有历史备份&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;find $DATA_DIR/ -type f -name &amp;quot;*.sql&amp;quot; -mtime +7 -exec rm -rf {} \;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;数据库查询一句话命令&lt;/p&gt;&#xA;&lt;p&gt;单引号引起来的起来的是命令&#xA;&lt;code&gt;docker run -ti --name mysql_t mysql:5.7.16 &#39; mysql -u root -proot -h 10.105.40.49 -e &amp;quot;show databases&amp;quot;&#39; ; docker stop mysql_t;docker rm mysql_t;&lt;/code&gt;&lt;/p&gt;&#xA;&lt;p&gt;一句话命令开启http访问当前页面&lt;/p&gt;&#xA;&lt;p&gt;&lt;code&gt;docker run -dti --name nginx_t -v /tmp/test:/usr/share/nginx/html -p 8080:80 nginx&lt;/code&gt;&lt;/p&gt;&#xA;&lt;h3 id=&#34;linux-快捷命令&#34;&gt;linux 快捷命令&lt;/h3&gt;</description>
    </item>
    <item>
      <title>大模型智能体构建：从理论到实践</title>
      <link>https://axfinn.github.io/blog/2025-07/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%99%BA%E8%83%BD%E4%BD%93%E6%9E%84%E5%BB%BA%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Fri, 18 Jul 2025 18:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%99%BA%E8%83%BD%E4%BD%93%E6%9E%84%E5%BB%BA%E4%BB%8E%E7%90%86%E8%AE%BA%E5%88%B0%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;随着大型语言模型（LLM）的飞速发展，构建能够自主感知、决策和行动的智能体（Agent）成为了人工智能领域的热点。大模型智能体不仅能够理解复杂的指令，还能通过与环境的交互，完成一系列任务。本文将深入探讨大模型智能体的构建原理、核心组件以及实践中的挑战与机遇。&lt;/p&gt;&#xA;&lt;h2 id=&#34;大模型智能体的核心组件&#34;&gt;大模型智能体的核心组件&lt;/h2&gt;&#xA;&lt;p&gt;一个典型的大模型智能体通常包含以下几个核心组件：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;感知模块（Perception Module）&lt;/strong&gt;：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;功能&lt;/strong&gt;：负责从环境中获取信息，并将其转化为LLM可以理解的格式。这是智能体与外部世界交互的第一步。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;输入模态&lt;/strong&gt;：可以处理多种模态的数据，包括但不限于：&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;文本&lt;/strong&gt;：网页内容、文档、聊天记录、数据库查询结果等。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;图像/视频&lt;/strong&gt;：通过图像识别、OCR（光学字符识别）、视频分析模型提取视觉信息。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;音频&lt;/strong&gt;：通过语音识别（ASR）将语音转化为文本。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;结构化数据&lt;/strong&gt;：如JSON、XML、CSV等，需要解析并转化为自然语言描述或LLM可理解的格式。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;关键技术&lt;/strong&gt;：数据预处理、特征提取、多模态信息融合、特定领域的解析器。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;/li&gt;&#xA;&lt;li&gt;&#xA;&lt;p&gt;&lt;strong&gt;规划模块（Planning Module）&lt;/strong&gt;：&lt;/p&gt;</description>
    </item>
    <item>
      <title>打造你的专属数字工作台：My Tool Dashboard 的设计与实践</title>
      <link>https://axfinn.github.io/blog/2025-07/%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E4%B8%93%E5%B1%9E%E6%95%B0%E5%AD%97%E5%B7%A5%E4%BD%9C%E5%8F%B0my-tool-dashboard-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Fri, 18 Jul 2025 18:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/%E6%89%93%E9%80%A0%E4%BD%A0%E7%9A%84%E4%B8%93%E5%B1%9E%E6%95%B0%E5%AD%97%E5%B7%A5%E4%BD%9C%E5%8F%B0my-tool-dashboard-%E7%9A%84%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h2 id=&#34;挑战散乱的数字工具与低效的工作流&#34;&gt;挑战：散乱的数字工具与低效的工作流&lt;/h2&gt;&#xA;&lt;p&gt;在数字化的今天，我们每个人都离不开各种在线工具：文档协作、代码托管、设计资源、数据分析……然而，随着工具数量的增长，我们常常面临以下痛点：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;工具分散&lt;/strong&gt;：常用的工具散落在浏览器收藏夹、各种笔记应用中，查找和访问效率低下。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;界面单调&lt;/strong&gt;：传统的导航页或浏览器主页功能单一，缺乏个性化和互动性，无法激发使用兴趣。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;缺乏统一管理&lt;/strong&gt;：难以集中管理和快速切换不同类别的工具，导致工作流碎片化。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;隐私与定制化不足&lt;/strong&gt;：许多在线工具导航页无法满足个人对界面、功能和数据隐私的深度定制需求。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;为了解决这些问题，我们构思并实现了一个高度可定制的个人工具导航页——&lt;strong&gt;My Tool Dashboard&lt;/strong&gt;。&lt;/p&gt;</description>
    </item>
    <item>
      <title>构建智能客服大脑：一个链式处理AI Agent的实践与思考</title>
      <link>https://axfinn.github.io/blog/2025-07/%E6%9E%84%E5%BB%BA%E6%99%BA%E8%83%BD%E5%AE%A2%E6%9C%8D%E5%A4%A7%E8%84%91%E4%B8%80%E4%B8%AA%E9%93%BE%E5%BC%8F%E5%A4%84%E7%90%86ai-agent%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%80%9D%E8%80%83/</link>
      <pubDate>Fri, 18 Jul 2025 18:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/%E6%9E%84%E5%BB%BA%E6%99%BA%E8%83%BD%E5%AE%A2%E6%9C%8D%E5%A4%A7%E8%84%91%E4%B8%80%E4%B8%AA%E9%93%BE%E5%BC%8F%E5%A4%84%E7%90%86ai-agent%E7%9A%84%E5%AE%9E%E8%B7%B5%E4%B8%8E%E6%80%9D%E8%80%83/</guid>
      <description>&lt;h2 id=&#34;挑战复杂客户投诉处理的痛点&#34;&gt;挑战：复杂客户投诉处理的痛点&lt;/h2&gt;&#xA;&lt;p&gt;在互联网服务的日常运营中，客户投诉是不可避免的一环。然而，许多投诉并非简单问题，尤其当它们涉及复杂的系统交互时，例如用户反馈“直播卡顿，需要查看日志并进行全链路分析”。这类问题往往需要：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;多源信息收集&lt;/strong&gt;：从日志系统、监控平台、用户行为数据等多个渠道获取信息。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;跨系统关联分析&lt;/strong&gt;：根据一个关键标识（如 &lt;code&gt;trace_id&lt;/code&gt;），关联不同服务间的调用链路。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;动态决策与任务分解&lt;/strong&gt;：根据初步分析结果，动态决定下一步需要执行的任务（例如，发现新的关联服务后，需要生成新的查询任务）。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;人工经验依赖&lt;/strong&gt;：整个过程高度依赖运维或客服人员的经验，效率低下且容易出错。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;为了解决这些痛点，我们设计并实现了一个&lt;strong&gt;链式处理AI Agent&lt;/strong&gt;，旨在将这一复杂、多步骤的客户投诉处理流程自动化、智能化。&lt;/p&gt;</description>
    </item>
    <item>
      <title>构建智能运维大脑：一个可动态发现任务的AI智能体实践</title>
      <link>https://axfinn.github.io/blog/2025-07/%E6%9E%84%E5%BB%BA%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4%E5%A4%A7%E8%84%91%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%8A%A8%E6%80%81%E5%8F%91%E7%8E%B0%E4%BB%BB%E5%8A%A1%E7%9A%84ai%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E8%B7%B5/</link>
      <pubDate>Fri, 18 Jul 2025 18:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/%E6%9E%84%E5%BB%BA%E6%99%BA%E8%83%BD%E8%BF%90%E7%BB%B4%E5%A4%A7%E8%84%91%E4%B8%80%E4%B8%AA%E5%8F%AF%E5%8A%A8%E6%80%81%E5%8F%91%E7%8E%B0%E4%BB%BB%E5%8A%A1%E7%9A%84ai%E6%99%BA%E8%83%BD%E4%BD%93%E5%AE%9E%E8%B7%B5/</guid>
      <description>&lt;h2 id=&#34;挑战复杂运维场景下的全链路分析困境&#34;&gt;挑战：复杂运维场景下的“全链路分析”困境&lt;/h2&gt;&#xA;&lt;p&gt;在大型互联网服务的日常运维中，我们经常面临这样的场景：用户反馈某个服务出现异常，例如“&lt;code&gt;live.live.app-blink&lt;/code&gt; 服务报错，需要查看错误日志并进行全链路分析”。&lt;/p&gt;&#xA;&lt;p&gt;这看似简单的需求，背后却隐藏着一个复杂且耗时的工作流：&lt;/p&gt;&#xA;&lt;ol&gt;&#xA;&lt;li&gt;&lt;strong&gt;日志初筛&lt;/strong&gt;：首先，需要从海量日志中精准定位到指定服务的错误日志。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;信息提取&lt;/strong&gt;：从日志中抽取出关键标识，例如 &lt;code&gt;trace_id&lt;/code&gt;。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;关联发现&lt;/strong&gt;：基于 &lt;code&gt;trace_id&lt;/code&gt;，需要进一步查询所有相关的上游和下游服务。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;任务分解&lt;/strong&gt;：为每个关联服务生成新的日志查询或指标分析任务。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;并行执行&lt;/strong&gt;：同时执行这些分散的任务。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;结果聚合&lt;/strong&gt;：将所有任务的结果汇总，形成一份完整的全链路分析报告。&lt;/li&gt;&#xA;&lt;/ol&gt;&#xA;&lt;p&gt;这个过程不仅需要人工介入大量查询和判断，而且效率低下，容易出错。为了解决这一痛点，我们构思并实现了一个&lt;strong&gt;链式处理AI智能体&lt;/strong&gt;，旨在将这一复杂流程自动化、智能化。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 客户端辅助模块：控制与 P2P 打洞细节</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97%E6%8E%A7%E5%88%B6%E4%B8%8E-p2p-%E6%89%93%E6%B4%9E%E7%BB%86%E8%8A%82/</link>
      <pubDate>Fri, 18 Jul 2025 18:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BE%85%E5%8A%A9%E6%A8%A1%E5%9D%97%E6%8E%A7%E5%88%B6%E4%B8%8E-p2p-%E6%89%93%E6%B4%9E%E7%BB%86%E8%8A%82/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在上一篇文章中，我们深入剖析了 NPS 客户端的核心 &lt;code&gt;client.go&lt;/code&gt;，了解了其连接管理和流量转发机制。本篇文章将继续探索 NPS 客户端的其他辅助模块，特别是 &lt;code&gt;nps/client/control.go&lt;/code&gt; 文件。这个文件包含了客户端的一些控制逻辑，例如获取任务状态、从配置文件启动客户端，以及一些 P2P UDP 打洞相关的辅助函数。&lt;/p&gt;&#xA;&lt;h2 id=&#34;controlgo客户端的控制中心&#34;&gt;&lt;code&gt;control.go&lt;/code&gt;：客户端的控制中心&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;control.go&lt;/code&gt; 文件提供了客户端的一些高级控制功能，使得用户可以通过配置文件或命令行参数来管理客户端的行为。&lt;/p&gt;&#xA;&lt;h3 id=&#34;tls-加密控制&#34;&gt;TLS 加密控制&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;control.go&lt;/code&gt; 中定义了 &lt;code&gt;tlsEnable1&lt;/code&gt; 变量以及 &lt;code&gt;SetTlsEnable()&lt;/code&gt; 和 &lt;code&gt;GetTlsEnable()&lt;/code&gt; 函数，用于控制客户端与服务端之间是否启用 TLS 加密。这为用户提供了在客户端层面配置加密传输的灵活性。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 客户端核心解析：连接管理与流量转发</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A0%B8%E5%BF%83%E8%A7%A3%E6%9E%90%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E4%B8%8E%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Fri, 18 Jul 2025 17:45:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%A0%B8%E5%BF%83%E8%A7%A3%E6%9E%90%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E4%B8%8E%E6%B5%81%E9%87%8F%E8%BD%AC%E5%8F%91/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在 NPS 系列文章的前几篇中，我们详细剖析了 NPS 服务端的各个模块和代理实现。本篇文章将转向 NPS 的 &lt;strong&gt;客户端（Client）&lt;/strong&gt; 模块，深入分析 &lt;code&gt;nps/client/client.go&lt;/code&gt; 文件。这个文件是 NPS 客户端的“大脑”，负责与服务端建立连接、管理隧道、处理不同类型的流量以及维护客户端的生命周期。理解客户端的运作机制，是掌握 NPS 完整内网穿透流程的关键。&lt;/p&gt;&#xA;&lt;h2 id=&#34;clientgo客户端的大脑&#34;&gt;&lt;code&gt;client.go&lt;/code&gt;：客户端的“大脑”&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;client.go&lt;/code&gt; 文件定义了 &lt;code&gt;TRPClient&lt;/code&gt; 结构体，它是 NPS 客户端的核心。它负责客户端的启动、与服务端的通信、隧道管理以及流量转发。&lt;/p&gt;&#xA;&lt;h3 id=&#34;trpclient-结构体&#34;&gt;&lt;code&gt;TRPClient&lt;/code&gt; 结构体&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;TRPClient&lt;/code&gt; 结构体包含了客户端运行所需的所有关键信息：&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 代理实现：HTTP/HTTPS 域名解析与高级功能</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0http/https-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%B8%8E%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/</link>
      <pubDate>Fri, 18 Jul 2025 17:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0http/https-%E5%9F%9F%E5%90%8D%E8%A7%A3%E6%9E%90%E4%B8%8E%E9%AB%98%E7%BA%A7%E5%8A%9F%E8%83%BD/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在 NPS 系列文章中，我们已经深入探讨了 NPS 的多种代理模式。本篇文章将聚焦于 NPS 的 &lt;strong&gt;HTTP/HTTPS 域名解析&lt;/strong&gt;功能，这是 NPS 实现 Web 服务穿透的核心。我们将通过分析 &lt;code&gt;nps/server/proxy/http.go&lt;/code&gt; 文件，揭示 NPS 如何处理 HTTP 和 HTTPS 请求，并实现缓存、认证、动态后端切换等高级功能。&lt;/p&gt;&#xA;&lt;h2 id=&#34;httphttps-域名解析的需求&#34;&gt;HTTP/HTTPS 域名解析的需求&lt;/h2&gt;&#xA;&lt;p&gt;在实际应用中，我们经常需要将内网的 Web 服务通过域名暴露到公网。这涉及到：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;域名到内网 IP 的映射&lt;/strong&gt;：根据请求的域名，将流量转发到内网中对应的 Web 服务器。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HTTP/HTTPS 协议处理&lt;/strong&gt;：NPS 需要能够处理标准的 HTTP 请求，以及加密的 HTTPS 请求。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;高级功能&lt;/strong&gt;：为了提升性能、安全性和灵活性，通常还需要支持缓存、认证、负载均衡、自动 HTTPS 等功能。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;httpgohttphttps-域名解析的实现&#34;&gt;&lt;code&gt;http.go&lt;/code&gt;：HTTP/HTTPS 域名解析的实现&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;http.go&lt;/code&gt; 文件定义了 &lt;code&gt;httpServer&lt;/code&gt; 结构体，它是 NPS 实现 HTTP/HTTPS 域名解析的核心。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 代理实现：HTTPS 代理与 SNI 证书管理</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0https-%E4%BB%A3%E7%90%86%E4%B8%8E-sni-%E8%AF%81%E4%B9%A6%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 18 Jul 2025 17:15:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0https-%E4%BB%A3%E7%90%86%E4%B8%8E-sni-%E8%AF%81%E4%B9%A6%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在 NPS 系列文章中，我们已经探讨了 NPS 的整体架构、服务端核心以及多种代理模式。本篇文章将深入 NPS 的 &lt;strong&gt;HTTPS 代理&lt;/strong&gt;实现。我们将通过分析 &lt;code&gt;nps/server/proxy/https.go&lt;/code&gt; 文件，揭示 NPS 如何处理加密的 HTTPS 流量，特别是其对 SNI（Server Name Indication）的支持和多证书管理机制。&lt;/p&gt;&#xA;&lt;h2 id=&#34;https-代理的需求与挑战&#34;&gt;HTTPS 代理的需求与挑战&lt;/h2&gt;&#xA;&lt;p&gt;HTTPS 代理比普通的 HTTP 代理更为复杂，因为它涉及到 SSL/TLS 加密。主要挑战包括：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;SSL/TLS 握手&lt;/strong&gt;：代理服务器需要参与 SSL/TLS 握手过程，解密客户端请求，然后加密转发给目标服务器，或者直接将加密流量转发给目标服务器。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;SNI 支持&lt;/strong&gt;：为了在同一个 IP 地址上托管多个 HTTPS 网站，客户端在 SSL/TLS 握手时会通过 SNI 扩展告知服务器其要访问的域名。代理服务器需要根据 SNI 信息选择正确的证书。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;证书管理&lt;/strong&gt;：代理服务器需要能够管理和加载多个域名的 SSL/TLS 证书。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;httpsgohttps-代理的实现&#34;&gt;&lt;code&gt;https.go&lt;/code&gt;：HTTPS 代理的实现&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;https.go&lt;/code&gt; 文件定义了 &lt;code&gt;HttpsServer&lt;/code&gt; 结构体，它是 NPS 实现 HTTPS 代理的核心。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 代理实现：WebSocket 代理与 HTTP 反向代理</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0websocket-%E4%BB%A3%E7%90%86%E4%B8%8E-http-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</link>
      <pubDate>Fri, 18 Jul 2025 17:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0websocket-%E4%BB%A3%E7%90%86%E4%B8%8E-http-%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在 NPS 系列文章的前几篇中，我们已经探讨了 NPS 的整体架构、服务端核心以及多种代理模式（TCP 隧道、HTTP 代理、SOCKS5 代理、P2P 代理和 UDP 代理）。本篇文章将深入 NPS 的 &lt;strong&gt;WebSocket 代理&lt;/strong&gt;和 &lt;strong&gt;HTTP 反向代理&lt;/strong&gt;实现。我们将通过分析 &lt;code&gt;nps/server/proxy/websocket.go&lt;/code&gt; 文件，揭示 NPS 如何处理这两种特殊的 HTTP 流量，实现更灵活的网络穿透。&lt;/p&gt;&#xA;&lt;h2 id=&#34;websocket-与-http-反向代理的需求&#34;&gt;WebSocket 与 HTTP 反向代理的需求&lt;/h2&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;strong&gt;WebSocket&lt;/strong&gt;：提供客户端和服务器之间的全双工通信通道，常用于实时应用，如聊天、在线游戏、股票行情等。传统的 HTTP 代理无法直接处理 WebSocket 协议的升级和持续连接。&lt;/li&gt;&#xA;&lt;li&gt;&lt;strong&gt;HTTP 反向代理&lt;/strong&gt;：将客户端的 HTTP 请求转发到后端服务器，并返回后端服务器的响应。它通常用于负载均衡、SSL 卸载、缓存和安全防护等。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;h2 id=&#34;websocketgowebsocket-与-http-反向代理的实现&#34;&gt;&lt;code&gt;websocket.go&lt;/code&gt;：WebSocket 与 HTTP 反向代理的实现&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;websocket.go&lt;/code&gt; 文件主要定义了 &lt;code&gt;HttpReverseProxy&lt;/code&gt; 和 &lt;code&gt;ReverseProxy&lt;/code&gt; 两个结构体，它们共同协作来处理 HTTP 反向代理和 WebSocket 连接。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 代理实现：UDP 代理与数据转发</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0udp-%E4%BB%A3%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91/</link>
      <pubDate>Fri, 18 Jul 2025 16:45:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0udp-%E4%BB%A3%E7%90%86%E4%B8%8E%E6%95%B0%E6%8D%AE%E8%BD%AC%E5%8F%91/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在 NPS 系列文章中，我们已经探讨了 NPS 的整体架构、服务端核心以及多种 TCP 相关的代理模式（TCP 隧道、HTTP 代理、SOCKS5 代理）和 P2P 代理。本篇文章将聚焦于 NPS 的 &lt;strong&gt;UDP 代理&lt;/strong&gt;实现。我们将通过分析 &lt;code&gt;nps/server/proxy/udp.go&lt;/code&gt; 文件，揭示 NPS 如何处理 UDP 流量，实现内网 UDP 服务的穿透。&lt;/p&gt;&#xA;&lt;h2 id=&#34;udp-代理的需求与挑战&#34;&gt;UDP 代理的需求与挑战&lt;/h2&gt;&#xA;&lt;p&gt;UDP（User Datagram Protocol）是一种无连接的传输协议，常用于对实时性要求较高、允许少量丢包的应用，如 DNS 查询、在线游戏、音视频通话等。由于 UDP 的无连接特性，其代理实现与 TCP 代理有所不同，主要挑战在于：&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 代理实现：P2P 协议与 UDP 打洞</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0p2p-%E5%8D%8F%E8%AE%AE%E4%B8%8E-udp-%E6%89%93%E6%B4%9E/</link>
      <pubDate>Fri, 18 Jul 2025 16:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0p2p-%E5%8D%8F%E8%AE%AE%E4%B8%8E-udp-%E6%89%93%E6%B4%9E/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在 NPS 系列文章中，我们已经探讨了 NPS 的整体架构、服务端核心以及 TCP 隧道、HTTP 代理和 SOCKS5 代理的实现。本篇文章将深入 NPS 的另一个高级代理模式——&lt;strong&gt;P2P 代理&lt;/strong&gt;。我们将通过分析 &lt;code&gt;nps/server/proxy/p2p.go&lt;/code&gt; 文件，揭示 NPS 如何利用 UDP 打洞技术，实现客户端之间的直接连接，从而在某些场景下提供更高效、更低延迟的内网穿透服务。&lt;/p&gt;&#xA;&lt;h2 id=&#34;p2p-代理的优势与挑战&#34;&gt;P2P 代理的优势与挑战&lt;/h2&gt;&#xA;&lt;p&gt;传统的内网穿透通常依赖于服务器进行数据中转，这会引入额外的延迟和带宽消耗。P2P（Peer-to-Peer）代理的目标是让内网中的两个客户端能够直接建立连接，绕过服务器中转，从而实现更高效的数据传输。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 代理实现：SOCKS5 协议深度解析</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0socks5-%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Fri, 18 Jul 2025 16:15:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0socks5-%E5%8D%8F%E8%AE%AE%E6%B7%B1%E5%BA%A6%E8%A7%A3%E6%9E%90/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在 NPS 系列文章的前几篇中，我们已经对 NPS 的整体架构、服务端核心以及 TCP 隧道和 HTTP 代理的实现有了初步了解。本篇文章将深入 NPS 的另一个重要代理模式——&lt;strong&gt;SOCKS5 代理&lt;/strong&gt;。我们将通过分析 &lt;code&gt;nps/server/proxy/socks5.go&lt;/code&gt; 文件，详细剖析 SOCKS5 协议在 NPS 中的实现细节，包括认证机制、请求处理以及 UDP 转发。&lt;/p&gt;&#xA;&lt;h2 id=&#34;socks5-协议简介&#34;&gt;SOCKS5 协议简介&lt;/h2&gt;&#xA;&lt;p&gt;SOCKS5 是一种网络代理协议，它允许客户端通过代理服务器间接访问其他服务器。与 HTTP 代理不同，SOCKS5 是一种更底层的协议，它不关心应用层协议（如 HTTP、FTP），而是直接转发 TCP 或 UDP 数据包。这使得 SOCKS5 代理更加通用，可以用于各种网络应用。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 代理实现：TCP 隧道与 HTTP 代理</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0tcp-%E9%9A%A7%E9%81%93%E4%B8%8E-http-%E4%BB%A3%E7%90%86/</link>
      <pubDate>Fri, 18 Jul 2025 16:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0tcp-%E9%9A%A7%E9%81%93%E4%B8%8E-http-%E4%BB%A3%E7%90%86/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在上一篇文章中，我们深入探讨了 &lt;code&gt;nps/server/proxy/base.go&lt;/code&gt; 中定义的通用代理基础和流量控制机制。本篇文章将聚焦于 NPS 最常用也是最基础的两种代理模式：&lt;strong&gt;TCP 隧道&lt;/strong&gt;和 &lt;strong&gt;HTTP 代理&lt;/strong&gt;。我们将通过分析 &lt;code&gt;nps/server/proxy/tcp.go&lt;/code&gt; 文件，揭示这两种模式的具体实现细节。&lt;/p&gt;&#xA;&lt;h2 id=&#34;tcpgotcp-隧道与-http-代理的实现&#34;&gt;&lt;code&gt;tcp.go&lt;/code&gt;：TCP 隧道与 HTTP 代理的实现&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;tcp.go&lt;/code&gt; 文件主要定义了 &lt;code&gt;TunnelModeServer&lt;/code&gt; 结构体，它是实现 TCP 隧道和 HTTP 代理的核心。此外，该文件还包含了 &lt;code&gt;WebServer&lt;/code&gt; 结构体，用于启动 NPS 的 Web 管理界面。&lt;/p&gt;&#xA;&lt;h3 id=&#34;tunnelmodeserver通用隧道模式服务器&#34;&gt;&lt;code&gt;TunnelModeServer&lt;/code&gt;：通用隧道模式服务器&lt;/h3&gt;&#xA;&lt;p&gt;&lt;code&gt;TunnelModeServer&lt;/code&gt; 结构体继承了 &lt;code&gt;BaseServer&lt;/code&gt;，并增加了两个特定于隧道模式的字段：&lt;/p&gt;&#xA;&lt;div class=&#34;highlight&#34;&gt;&lt;pre tabindex=&#34;0&#34; class=&#34;chroma&#34;&gt;&lt;code class=&#34;language-go&#34; data-lang=&#34;go&#34;&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;kd&#34;&gt;type&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;TunnelModeServer&lt;/span&gt; &lt;span class=&#34;kd&#34;&gt;struct&lt;/span&gt; &lt;span class=&#34;p&#34;&gt;{&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;BaseServer&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;process&lt;/span&gt;  &lt;span class=&#34;nx&#34;&gt;process&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;    &lt;span class=&#34;nx&#34;&gt;listener&lt;/span&gt; &lt;span class=&#34;nx&#34;&gt;net&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;nx&#34;&gt;Listener&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;span class=&#34;line&#34;&gt;&lt;span class=&#34;cl&#34;&gt;&lt;span class=&#34;p&#34;&gt;}&lt;/span&gt;&#xA;&lt;/span&gt;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;BaseServer&lt;/code&gt;：继承了 &lt;code&gt;base.go&lt;/code&gt; 中定义的通用功能，如流量统计、安全检查等。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;process process&lt;/code&gt;：这是一个函数类型 &lt;code&gt;type process func(c *conn.Conn, s *TunnelModeServer) error&lt;/code&gt;，它定义了如何处理传入的客户端连接。不同的代理模式会传入不同的 &lt;code&gt;process&lt;/code&gt; 函数。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;listener net.Listener&lt;/code&gt;：用于监听传入连接的网络监听器。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;&lt;code&gt;NewTunnelModeServer()&lt;/code&gt; 函数用于创建并初始化一个 &lt;code&gt;TunnelModeServer&lt;/code&gt; 实例。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 代理实现：通用基础与流量控制</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E9%80%9A%E7%94%A8%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</link>
      <pubDate>Fri, 18 Jul 2025 15:45:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E4%BB%A3%E7%90%86%E5%AE%9E%E7%8E%B0%E9%80%9A%E7%94%A8%E5%9F%BA%E7%A1%80%E4%B8%8E%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在 NPS 服务端核心解析中，我们了解了 &lt;code&gt;server.go&lt;/code&gt; 如何作为服务端的“大脑”，协调各项任务。本篇文章将深入 NPS 的代理实现细节，从 &lt;code&gt;nps/server/proxy/base.go&lt;/code&gt; 文件入手，剖析所有代理服务共用的基础结构、接口定义以及流量控制、安全检查等通用逻辑。理解这些通用组件，有助于我们更好地把握 NPS 多样化代理模式的实现原理。&lt;/p&gt;&#xA;&lt;h2 id=&#34;basego代理服务的基石&#34;&gt;&lt;code&gt;base.go&lt;/code&gt;：代理服务的基石&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;base.go&lt;/code&gt; 文件定义了 NPS 中所有代理服务的基础抽象和通用功能。它确保了不同代理模式（如 TCP、UDP、SOCKS5、HTTP 等）能够遵循统一的接口规范，并共享一些核心的辅助功能。&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 服务端核心解析：架构与流量管理</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A0%B8%E5%BF%83%E8%A7%A3%E6%9E%90%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86/</link>
      <pubDate>Fri, 18 Jul 2025 15:30:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E6%9C%8D%E5%8A%A1%E7%AB%AF%E6%A0%B8%E5%BF%83%E8%A7%A3%E6%9E%90%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%B5%81%E9%87%8F%E7%AE%A1%E7%90%86/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在 NPS 项目概述中，我们对这款强大的内网穿透工具进行了宏观的介绍。本篇文章将深入 NPS 的服务端（Server）核心，从 &lt;code&gt;nps/server/server.go&lt;/code&gt; 文件入手，详细剖析其架构设计、任务管理、流量处理以及系统监控等关键功能。理解 &lt;code&gt;server.go&lt;/code&gt; 的运作机制，是掌握 NPS 核心原理的基石。&lt;/p&gt;&#xA;&lt;h2 id=&#34;servergo服务端的大脑&#34;&gt;&lt;code&gt;server.go&lt;/code&gt;：服务端的&amp;quot;大脑&amp;quot;&lt;/h2&gt;&#xA;&lt;p&gt;&lt;code&gt;server.go&lt;/code&gt; 文件是 NPS 服务端的启动入口和主要协调者。它负责初始化各项服务、管理客户端连接、调度隧道任务以及收集系统运行状态。&lt;/p&gt;&#xA;&lt;h3 id=&#34;核心组件概览&#34;&gt;核心组件概览&lt;/h3&gt;&#xA;&lt;p&gt;在 &lt;code&gt;server.go&lt;/code&gt; 中，我们可以看到几个关键的全局变量和结构：&lt;/p&gt;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;&lt;code&gt;Bridge *bridge.Bridge&lt;/code&gt;：这是服务端与客户端之间通信的核心桥梁。它负责维护客户端连接、处理客户端发送的指令以及转发数据。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;RunList sync.Map&lt;/code&gt;：一个并发安全的 Map，用于存储当前正在运行的所有隧道（&lt;code&gt;proxy.Service&lt;/code&gt; 实例）。通过 &lt;code&gt;sync.Map&lt;/code&gt;，NPS 能够高效地管理和访问多个并发的隧道服务。&lt;/li&gt;&#xA;&lt;li&gt;&lt;code&gt;once sync.Once&lt;/code&gt;：用于确保某些初始化操作（如 &lt;code&gt;flowSession&lt;/code&gt;）只执行一次。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&lt;p&gt;NPS 服务端核心组件架构可以用下图表示：&lt;/p&gt;</description>
    </item>
    <item>
      <title>NPS 项目概述：内网穿透利器</title>
      <link>https://axfinn.github.io/blog/2025-07/nps-%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%88%A9%E5%99%A8/</link>
      <pubDate>Fri, 18 Jul 2025 15:00:00 +0800</pubDate>
      <guid>https://axfinn.github.io/blog/2025-07/nps-%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%BF%B0%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%88%A9%E5%99%A8/</guid>
      <description>&lt;h2 id=&#34;引言&#34;&gt;引言&lt;/h2&gt;&#xA;&lt;p&gt;在现代网络环境中，内网穿透技术扮演着越来越重要的角色。无论是进行本地开发调试、远程访问内网资源，还是搭建个人服务，内网穿透都能提供极大的便利。今天，我们将深入剖析一个功能强大、性能卓越的内网穿透代理服务器项目——NPS。&lt;/p&gt;&#xA;&lt;h2 id=&#34;什么是-nps&#34;&gt;什么是 NPS？&lt;/h2&gt;&#xA;&lt;p&gt;NPS 是一款轻量级、高性能、功能强大的&lt;strong&gt;内网穿透&lt;/strong&gt;代理服务器。它旨在帮助用户轻松实现内网资源的外部访问，打破网络边界的限制。NPS 不仅仅是一个简单的端口转发工具，它更是一个集多种代理协议、Web 管理界面和丰富扩展功能于一体的综合性解决方案。&lt;/p&gt;</description>
    </item>
  </channel>
</rss>
